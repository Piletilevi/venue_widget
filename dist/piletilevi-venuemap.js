/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Piletilevi; });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction Piletilevi() {}\n\nvar __DraggableComponent = function __DraggableComponent() {\n  var draggableElement;\n  var parentElement;\n  var gestureElement;\n  var boundariesElement;\n  var boundariesPadding;\n  var startElementX;\n  var startElementY;\n  var currentElementX;\n  var currentElementY;\n  var startTouchX;\n  var startTouchY;\n  var currentTouchX;\n  var currentTouchY;\n  var beforeStartCallback;\n  var startCallback;\n  var beforeMoveCallback;\n  var afterMoveCallback;\n  var endCallback;\n  var dragTolerance = 2;\n\n  this.registerDraggableElement = function (parameters) {\n    if (_typeof(parameters) == 'object') {\n      if (parameters.draggableElement !== undefined) {\n        draggableElement = parameters.draggableElement;\n      }\n\n      if (parameters.parentElement !== undefined) {\n        parentElement = parameters.parentElement;\n      } else if (draggableElement) {\n        parentElement = draggableElement.parentNode;\n      }\n\n      if (parameters.gestureElement !== undefined) {\n        gestureElement = parameters.gestureElement;\n      } else if (draggableElement) {\n        gestureElement = draggableElement;\n      }\n\n      if (parameters.boundariesElement !== undefined) {\n        boundariesElement = parameters.boundariesElement;\n      }\n\n      if (parameters.boundariesPadding !== undefined) {\n        boundariesPadding = parseFloat(parameters.boundariesPadding);\n      } else {\n        boundariesPadding = 0;\n      }\n\n      if (typeof parameters.beforeStartCallback === 'function') {\n        beforeStartCallback = parameters.beforeStartCallback;\n      }\n\n      if (typeof parameters.startCallback === 'function') {\n        startCallback = parameters.startCallback;\n      }\n\n      if (typeof parameters.beforeMoveCallback === 'function') {\n        beforeMoveCallback = parameters.beforeMoveCallback;\n      }\n\n      if (typeof parameters.afterMoveCallback === 'function') {\n        afterMoveCallback = parameters.afterMoveCallback;\n      }\n\n      if (typeof parameters.endCallback === 'function') {\n        endCallback = parameters.endCallback;\n      }\n\n      initDraggableElement();\n    }\n  };\n\n  this.disableDragging = function () {\n    if (!draggableElement) {\n      return;\n    }\n\n    removeDraggableElement();\n  };\n\n  this.enableDragging = function () {\n    if (!draggableElement) {\n      return;\n    }\n\n    initDraggableElement();\n  };\n\n  var initDraggableElement = function initDraggableElement() {\n    removeDraggableElement();\n    draggableElement.setAttribute('data-draggable-state', 'draggable');\n    touchManager.addEventListener(gestureElement, 'start', startHandler, true);\n  };\n\n  var removeDraggableElement = function removeDraggableElement() {\n    draggableElement.removeAttribute('data-draggable-state');\n    touchManager.removeEventListener(gestureElement, 'start', startHandler);\n    touchManager.removeEventListener(gestureElement, 'move', moveHandler);\n    touchManager.removeEventListener(gestureElement, 'cancel', endHandler);\n    touchManager.removeEventListener(gestureElement, 'end', endHandler);\n  };\n\n  var startHandler = function startHandler(eventInfo, touchInfo) {\n    if (typeof touchInfo.touches !== 'undefined' && touchInfo.touches.length === 1) {\n      draggableElement.setAttribute('data-draggable-state', 'dragging');\n      startElementX = draggableElement.offsetLeft;\n      startElementY = draggableElement.offsetTop;\n      startTouchX = touchInfo.touches[0].pageX;\n      startTouchY = touchInfo.touches[0].pageY;\n      currentTouchX = startTouchX;\n      currentTouchY = startTouchY;\n\n      if (typeof beforeStartCallback === 'undefined' || beforeStartCallback(compileInfo())) {\n        touchManager.addEventListener(gestureElement, 'move', moveHandler, true);\n        touchManager.addEventListener(gestureElement, 'end', endHandler, true);\n        touchManager.addEventListener(gestureElement, 'cancel', endHandler, true);\n\n        if (startCallback) {\n          startCallback(compileInfo());\n        }\n      }\n    }\n  };\n\n  var moveHandler = function moveHandler(eventInfo, touchInfo) {\n    if (touchInfo.touches !== undefined && touchInfo.touches.length === 1) {\n      eventInfo.preventDefault();\n      currentTouchX = touchInfo.touches[0].pageX;\n      currentTouchY = touchInfo.touches[0].pageY;\n      currentElementX = startElementX + currentTouchX - startTouchX;\n      currentElementY = startElementY + currentTouchY - startTouchY;\n\n      if (boundariesElement) {\n        var minX;\n        var maxX;\n        var minY;\n        var maxY;\n\n        if (currentElementX > (minX = boundariesElement.offsetWidth * boundariesPadding)) {\n          currentElementX = minX;\n        } else if (currentElementX < (maxX = boundariesElement.offsetWidth * (1 - boundariesPadding) - draggableElement.offsetWidth)) {\n          currentElementX = maxX;\n        }\n\n        if (currentElementY > (minY = boundariesElement.offsetHeight * boundariesPadding)) {\n          currentElementY = minY;\n        }\n\n        if (currentElementY < (maxY = boundariesElement.offsetHeight * (1 - boundariesPadding) - draggableElement.offsetHeight)) {\n          currentElementY = maxY;\n        }\n      }\n\n      if (beforeMoveCallback === undefined || beforeMoveCallback(compileInfo())) {\n        draggableElement.style.left = currentElementX + 'px';\n        draggableElement.style.top = currentElementY + 'px';\n\n        if (afterMoveCallback) {\n          afterMoveCallback(compileInfo());\n        }\n      }\n    }\n  };\n\n  var endHandler = function endHandler(eventInfo) {\n    if (Math.abs(startTouchX - currentTouchX) > dragTolerance || Math.abs(startTouchY - currentTouchY) > dragTolerance) {\n      eventInfo.stopPropagation();\n    }\n\n    eventInfo.preventDefault();\n    draggableElement.setAttribute('data-draggable-state', 'draggable');\n    touchManager.removeEventListener(gestureElement, 'move', moveHandler);\n    touchManager.removeEventListener(gestureElement, 'end', endHandler);\n    touchManager.removeEventListener(gestureElement, 'cancel', endHandler);\n\n    if (endCallback) {\n      endCallback(compileInfo());\n    }\n  };\n\n  var compileInfo = function compileInfo() {\n    return {\n      'draggableElement': draggableElement,\n      'parentElement': parentElement,\n      'gestureElement': gestureElement,\n      'startElementX': startElementX,\n      'startElementY': startElementY,\n      'currentElementX': currentElementX,\n      'currentElementY': currentElementY,\n      'startTouchX': startTouchX,\n      'startTouchY': startTouchY,\n      'currentTouchX': currentTouchX,\n      'currentTouchY': currentTouchY\n    };\n  };\n};\n\nvar __ScalableComponent = function __ScalableComponent() {\n  var scaledElement;\n  var gestureElement;\n  var beforeStartCallback;\n  var afterStartCallback;\n  var afterChangeCallback;\n  var preChangeCallback;\n  var endCallback;\n  var speedX = 1;\n  var speedY = 1;\n  var minWidth;\n  var minHeight;\n  var maxWidth;\n  var maxHeight;\n  var scale;\n  var startWidth;\n  var startHeight;\n  var currentWidth;\n  var currentHeight;\n  var startF0x;\n  var startF0y;\n  var startF1x;\n  var startF1y;\n  var startDistance;\n  var f0x;\n  var f0y;\n  var f1x;\n  var f1y;\n\n  this.registerScalableElement = function (parameters) {\n    if (_typeof(parameters) == 'object') {\n      if (parameters.scaledElement !== undefined) {\n        scaledElement = parameters.scaledElement;\n      }\n\n      if (parameters.gestureElement !== undefined) {\n        gestureElement = parameters.gestureElement;\n      } else {\n        gestureElement = scaledElement;\n      }\n\n      if (parameters.scaledElement !== undefined) {\n        scaledElement = parameters.scaledElement;\n      }\n\n      if (typeof parameters.beforeStartCallback === 'function') {\n        beforeStartCallback = parameters.beforeStartCallback;\n      }\n\n      if (typeof parameters.afterStartCallback === 'function') {\n        afterStartCallback = parameters.afterStartCallback;\n      }\n\n      if (typeof parameters.afterChangeCallback === 'function') {\n        afterChangeCallback = parameters.afterChangeCallback;\n      }\n\n      if (typeof parameters.preChangeCallback === 'function') {\n        preChangeCallback = parameters.preChangeCallback;\n      }\n\n      if (typeof parameters.endCallback === 'function') {\n        endCallback = parameters.endCallback;\n      }\n\n      if (typeof parameters.speedX !== 'undefined') {\n        speedX = parseFloat(parameters.speedX, 10);\n      } else {\n        speedX = 1;\n      }\n\n      if (typeof parameters.speedY !== 'undefined') {\n        speedY = parseFloat(parameters.speedY, 10);\n      } else {\n        speedY = 1;\n      }\n\n      if (typeof parameters.minWidth !== 'undefined') {\n        minWidth = parseInt(parameters.minWidth, 10);\n      }\n\n      if (typeof parameters.minHeight !== 'undefined') {\n        minHeight = parseInt(parameters.minHeight, 10);\n      }\n\n      if (typeof parameters.maxWidth !== 'undefined') {\n        maxWidth = parseInt(parameters.maxWidth, 10);\n      }\n\n      if (typeof parameters.maxHeight !== 'undefined') {\n        maxHeight = parseInt(parameters.maxHeight, 10);\n      }\n\n      initScalableElement();\n    }\n  };\n\n  this.unRegisterScalableElement = function () {\n    removeScalableElement();\n  };\n\n  var initScalableElement = function initScalableElement() {\n    removeScalableElement(); //\t0005505: TÃ¤issaaliplaani kiirus\n\n    if (window.userAgent !== 'Firefox') {\n      touchManager.setTouchAction(gestureElement, 'none'); // disable browser-related touch manipulation\n    }\n\n    touchManager.addEventListener(gestureElement, 'start', startHandler, true);\n  };\n\n  var removeScalableElement = function removeScalableElement() {\n    touchManager.removeEventListener(gestureElement, 'start', startHandler);\n    touchManager.removeEventListener(gestureElement, 'move', moveHandler);\n    touchManager.removeEventListener(gestureElement, 'cancel', endHandler);\n    touchManager.removeEventListener(gestureElement, 'end', endHandler);\n  };\n\n  var startHandler = function startHandler(eventInfo, touchInfo) {\n    if (typeof touchInfo.touches !== 'undefined' && touchInfo.touches.length > 1) {\n      eventInfo.preventDefault();\n      scale = 1;\n\n      if (scaledElement.tagName.toUpperCase() === 'SVG') {\n        // not all browsers provide offsetWidth/Height for SVGs\n        var svgBoxInfo = scaledElement.getBoundingClientRect();\n        startWidth = svgBoxInfo.width;\n        startHeight = svgBoxInfo.height;\n      } else {\n        startWidth = scaledElement.offsetWidth;\n        startHeight = scaledElement.offsetHeight;\n      }\n\n      startF0x = touchInfo.touches[0].pageX;\n      startF0y = touchInfo.touches[0].pageY;\n      startF1x = touchInfo.touches[1].pageX;\n      startF1y = touchInfo.touches[1].pageY;\n      startDistance = Math.pow(Math.pow(startF1x - startF0x, 2) + Math.pow(startF1y - startF0y, 2), 0.5);\n\n      if (beforeStartCallback === undefined || beforeStartCallback(compileInfo())) {\n        touchManager.addEventListener(gestureElement, 'move', moveHandler, true);\n        touchManager.addEventListener(gestureElement, 'end', endHandler, true);\n        touchManager.addEventListener(gestureElement, 'cancel', endHandler, true);\n\n        if (afterStartCallback) {\n          afterStartCallback(compileInfo());\n        }\n      }\n    }\n  };\n\n  var moveHandler = function moveHandler(eventInfo, touchInfo) {\n    if (typeof touchInfo.touches !== 'undefined' && touchInfo.touches.length > 1) {\n      eventInfo.preventDefault();\n      f0x = touchInfo.touches[0].pageX;\n      f0y = touchInfo.touches[0].pageY;\n      f1x = touchInfo.touches[1].pageX;\n      f1y = touchInfo.touches[1].pageY;\n      var distance = Math.pow(Math.pow(f1x - f0x, 2) + Math.pow(f1y - f0y, 2), 0.5);\n      scale = distance / startDistance;\n\n      if (scale !== 1) {\n        var scaleChange = 1 - scale;\n        currentWidth = startWidth - startWidth * scaleChange * speedX;\n\n        if (currentWidth > maxWidth) {\n          currentWidth = maxWidth;\n        }\n\n        if (currentWidth < minWidth) {\n          currentWidth = minWidth;\n        }\n\n        currentHeight = startHeight - startHeight * scaleChange * speedY;\n\n        if (currentHeight > maxHeight) {\n          currentHeight = maxHeight;\n        }\n\n        if (currentHeight < minHeight) {\n          currentHeight = minHeight;\n        }\n\n        if (preChangeCallback) {\n          preChangeCallback(compileInfo());\n        }\n\n        scaledElement.style.width = currentWidth + 'px';\n        scaledElement.style.height = currentHeight + 'px';\n\n        if (afterChangeCallback) {\n          afterChangeCallback(compileInfo());\n        }\n      }\n    }\n  };\n\n  var endHandler = function endHandler(eventInfo, touchInfo) {\n    eventInfo.preventDefault();\n    eventInfo.stopPropagation(); //end event can be fired multiple times. we should only remove handlers after all pointers are removed.\n\n    if (typeof touchInfo.touches !== 'undefined' && touchInfo.touches.length === 0) {\n      touchManager.removeEventListener(gestureElement, 'move', moveHandler);\n      touchManager.removeEventListener(gestureElement, 'end', endHandler);\n      touchManager.removeEventListener(gestureElement, 'cancel', endHandler);\n\n      if (endCallback) {\n        endCallback(compileInfo());\n      }\n    }\n  };\n\n  var compileInfo = function compileInfo() {\n    return {\n      'speedX': speedX,\n      'speedY': speedY,\n      'minWidth': minWidth,\n      'minHeight': minHeight,\n      'maxWidth': maxWidth,\n      'maxHeight': maxHeight,\n      'scale': scale,\n      'startWidth': startWidth,\n      'startHeight': startHeight,\n      'currentWidth': currentWidth,\n      'currentHeight': currentHeight,\n      'startF0x': startF0x,\n      'startF0y': startF0y,\n      'startF1x': startF1x,\n      'startF1y': startF1y,\n      'startDistance': startDistance,\n      'f0x': f0x,\n      'f0y': f0y,\n      'f1x': f1x,\n      'f1y': f1y\n    };\n  };\n};\n\nwindow.touchManager = new function () {\n  var self = this;\n  var handlers = {};\n  var eventsSet;\n  var startEventName;\n  var moveEventName;\n  var endEventName;\n  var cancelEventName;\n  var pointerCache = {};\n\n  var init = function init() {\n    handlers['start'] = [];\n    handlers['end'] = [];\n    handlers['move'] = [];\n    handlers['cancel'] = [];\n    eventsSet = self.getEventsSet();\n\n    if (eventsSet === 'mouse') {\n      captureStartEvent = captureStartEvent_mouse;\n      captureEndEvent = captureEndEvent_mouse;\n      compileEventInfo = compileEventInfo_mouse;\n      startEventName = 'mousedown';\n      moveEventName = 'mousemove';\n      endEventName = 'mouseup';\n      cancelEventName = 'mouseleave';\n    } else if (eventsSet === 'touch') {\n      compileEventInfo = compileEventInfo_touch;\n      startEventName = 'touchstart';\n      moveEventName = 'touchmove';\n      endEventName = 'touchend';\n      cancelEventName = 'touchcancel';\n    } else if (eventsSet === 'pointer') {\n      compileEventInfo = compileEventInfo_pointer;\n      startEventName = 'pointerdown';\n      moveEventName = 'pointermove';\n      endEventName = 'pointerup';\n      cancelEventName = 'pointercancel';\n    } else if (eventsSet === 'mspointer') {\n      compileEventInfo = compileEventInfo_mouse;\n      startEventName = 'mspointerdown';\n      moveEventName = 'mspointermove';\n      endEventName = 'mspointerup';\n      cancelEventName = 'mspointercancel';\n    }\n\n    window.addEventListener('load', initDom);\n  };\n\n  var initDom = function initDom() {\n    switch (eventsSet) {\n      case 'pointer':\n      case 'mspointer':\n        // cache pointers in these events for multi touch support\n        document.body.addEventListener(endEventName, pointerUp, true);\n        document.body.addEventListener(cancelEventName, pointerUp, true);\n        document.body.addEventListener(startEventName, pointerDown, true);\n        document.body.addEventListener(moveEventName, pointerMove, true);\n        break;\n    }\n  };\n\n  this.getEventsSet = function () {\n    eventsSet = false;\n\n    if (window.PointerEvent) {\n      //IE >=11, somebody else?\n      eventsSet = 'pointer';\n    } else if (window.navigator.msPointerEnabled) {\n      //IE mobile <=10\n      eventsSet = 'mspointer';\n    } else if ('ontouchstart' in window) {\n      eventsSet = 'touch';\n    } else if ('onmousedown' in window) {\n      eventsSet = 'mouse';\n    }\n\n    self.getEventsSet = getEventsSet_return;\n    return eventsSet;\n  };\n\n  var getEventsSet_return = function getEventsSet_return() {\n    return eventsSet;\n  };\n\n  var captureStartEvent = function captureStartEvent(event) {\n    fireCallback('start', event);\n  };\n\n  var captureStartEvent_mouse = function captureStartEvent_mouse(event) {\n    if (event.button === 0) {\n      fireCallback('start', event);\n    }\n  };\n\n  var captureMoveEvent = function captureMoveEvent(event) {\n    fireCallback('move', event);\n  };\n\n  var captureEndEvent = function captureEndEvent(event) {\n    fireCallback('end', event);\n  };\n\n  var captureCancelEvent = function captureCancelEvent(event) {\n    fireCallback('cancel', event);\n  };\n\n  var captureEndEvent_mouse = function captureEndEvent_mouse(event) {\n    if (event.button === 0) {\n      var eventType = 'end';\n      fireCallback(eventType, event);\n    }\n  };\n\n  var fireCallback = function fireCallback(eventType, event) {\n    var eventInfo = compileEventInfo(event); //first gather callbacks, then run them. just in case they modify handlers.\n\n    var callBacks = [];\n\n    for (var i = 0; i < handlers[eventType].length; i++) {\n      if (handlers[eventType][i]['element'] === eventInfo['currentTarget']) {\n        callBacks.push(handlers[eventType][i]['callback']);\n      }\n    }\n\n    for (var _i = 0; _i < callBacks.length; _i++) {\n      callBacks[_i](event, eventInfo);\n    }\n  };\n\n  var compileEventInfo;\n\n  var compileEventInfo_touch = function compileEventInfo_touch(event) {\n    var eventInfo = {\n      'target': event.target,\n      'currentTarget': event.currentTarget,\n      'touches': event.touches\n    };\n\n    if (typeof event.touches[0] !== 'undefined') {\n      var firstTouch = event.touches[0];\n      eventInfo['clientX'] = firstTouch.clientX;\n      eventInfo['clientY'] = firstTouch.clientY;\n      eventInfo['pageX'] = firstTouch.pageX;\n      eventInfo['pageY'] = firstTouch.pageY;\n    }\n\n    return eventInfo;\n  };\n\n  var compileEventInfo_pointer = function compileEventInfo_pointer(event) {\n    var touches = [];\n\n    for (var id in pointerCache) {\n      touches.push(pointerCache[id]);\n    }\n\n    return {\n      'touches': touches,\n      'target': event.target,\n      'currentTarget': event.currentTarget,\n      'clientX': event.clientX,\n      'clientY': event.clientY,\n      'pageX': event.pageX,\n      'pageY': event.pageY\n    };\n  };\n\n  var compileEventInfo_mouse = function compileEventInfo_mouse(event) {\n    var currentTouchInfo = {\n      'clientX': event.clientX,\n      'clientY': event.clientY,\n      'pageX': event.pageX,\n      'pageY': event.pageY\n    };\n    return {\n      'touches': [currentTouchInfo],\n      'target': event.target,\n      'currentTarget': event.currentTarget,\n      'clientX': event.clientX,\n      'clientY': event.clientY,\n      'pageX': event.pageX,\n      'pageY': event.pageY\n    };\n  };\n\n  var cachePointerEvent = function cachePointerEvent(event) {\n    if (typeof event.pointerId !== 'undefined') {\n      pointerCache[event.pointerId] = {\n        'clientX': event.clientX,\n        'clientY': event.clientY,\n        'pageX': event.pageX,\n        'pageY': event.pageY\n      };\n    }\n  };\n\n  var uncachePointerEvent = function uncachePointerEvent(event) {\n    if (typeof event.pointerId !== 'undefined') {\n      if (typeof pointerCache[event.pointerId] !== 'undefined') {\n        delete pointerCache[event.pointerId];\n      }\n    }\n  };\n\n  var pointerUp = function pointerUp(event) {\n    uncachePointerEvent(event);\n  };\n\n  var pointerDown = function pointerDown(event) {\n    cachePointerEvent(event);\n  };\n\n  var pointerMove = function pointerMove(event) {\n    cachePointerEvent(event);\n  };\n\n  this.addEventListener = function (element, eventType, callback, useCapture) {\n    if (!useCapture) {\n      useCapture = false;\n    }\n\n    if (typeof handlers[eventType] !== 'undefined') {\n      var handlerExists = false;\n\n      for (var i = 0; i < handlers[eventType].length; i++) {\n        if (handlers[eventType][i]['callback'] === callback && handlers[eventType][i]['element'] === element) {\n          handlerExists = true;\n          break;\n        }\n      }\n\n      if (!handlerExists) {\n        var handlerObject = {};\n        handlerObject['callback'] = callback;\n        handlerObject['element'] = element;\n        handlers[eventType].push(handlerObject);\n      }\n\n      if (typeof element !== 'undefined' && typeof callback !== 'undefined') {\n        if (eventType === 'start') {\n          element.addEventListener(startEventName, captureStartEvent, useCapture);\n        } else if (eventType === 'move') {\n          element.addEventListener(moveEventName, captureMoveEvent, useCapture);\n        } else if (eventType === 'end') {\n          element.addEventListener(endEventName, captureEndEvent, useCapture);\n        } else if (eventType === 'cancel') {\n          element.addEventListener(cancelEventName, captureCancelEvent, useCapture);\n        }\n      }\n    }\n  };\n\n  this.removeEventListener = function (element, eventType, callback) {\n    if (typeof handlers[eventType] !== 'undefined') {\n      for (var i = 0; i < handlers[eventType].length; i++) {\n        if (handlers[eventType][i]['callback'] === callback && handlers[eventType][i]['element'] === element) {\n          handlers[eventType][i] = null;\n          handlers[eventType].splice(i, 1);\n        }\n      }\n    }\n  };\n\n  this.setTouchAction = function (element, action) {\n    if (eventsSet === 'mspointer') {\n      // IE10\n      element.style.msTouchAction = action;\n    } else {\n      element.style.touchAction = action;\n    }\n  };\n\n  init();\n}();\nPiletilevi.venuemap = {\n  SHOP_DOMAIN: 'shop.piletilevi.ee',\n  DEFAULT_SEAT_HOVER_COLOR: '#27272e',\n  DEFAULT_SEAT_ACTIVE_COLOR: '#27272e',\n  DEFAULT_SEAT_INACTIVE_COLOR: '#d0d0d0',\n  SEAT_CIRCLE_RADIUS: 6,\n  STAGE_TEXT_SIZE: 20,\n  DEBUG_FULL_PLACESMAP_SECTIONS: false\n};\n\nPiletilevi.venuemap.PlacesMapSeatInfo = function (id, row, place, price, available, priceClass) {\n  this.id = id;\n  this.row = row;\n  this.place = place;\n  this.price = price;\n  this.available = !!available;\n  this.priceClass = priceClass;\n};\n\nPiletilevi.venuemap.PlacesMapPriceClassInfo = function (id, color, price) {\n  this.id = id;\n  this.color = color;\n  this.price = price;\n};\n\nPiletilevi.venuemap.SectionDetails = function (id, selectableSeats, seatsInfo, priceClasses) {\n  this.id = id;\n  this.selectableSeats = selectableSeats;\n  this.seatsInfo = seatsInfo;\n  this.priceClasses = priceClasses;\n};\n\nPiletilevi.venuemap.Utilities = new function () {\n  var self = this;\n  var animations = [];\n  var transitionsAndEvents = {\n    'transition': 'transitionend',\n    'OTransition': 'oTransitionEnd',\n    'MozTransition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd'\n  };\n  var supportedTransition = '';\n  var transitionSupportChecked = false;\n\n  var anim = function anim(element, properties, duration, easeMode, onComplete) {\n    var init = function init() {\n      this.element = element;\n      self.checkTransitionSupport();\n\n      if (supportedTransition) {\n        var transitions = [];\n\n        for (var key in properties) {\n          transitions.push(key + ' ' + duration + 'ms' + ' ' + (easeMode || 'linear'));\n        }\n\n        element.style[supportedTransition] = transitions.join(', ');\n      }\n\n      for (var _key in properties) {\n        element.style[_key] = properties[_key];\n      }\n\n      if (supportedTransition) {\n        element.addEventListener(transitionsAndEvents[supportedTransition], transitionend);\n      } else if (typeof onComplete === 'function') {\n        onComplete();\n      }\n    };\n\n    var transitionend = function transitionend() {\n      finish();\n      element.removeEventListener(transitionsAndEvents[supportedTransition], transitionend);\n    };\n\n    var finish = function finish() {\n      if (element) {\n        element.style[supportedTransition] = '';\n      }\n\n      if (typeof onComplete === 'function') {\n        onComplete();\n      }\n    };\n\n    this.cancel = function () {\n      element.removeEventListener(transitionsAndEvents[supportedTransition], transitionend);\n    };\n\n    init();\n  };\n\n  this.checkTransitionSupport = function () {\n    if (transitionSupportChecked) {\n      return;\n    }\n\n    for (var key in transitionsAndEvents) {\n      if (key in document.body.style) {\n        supportedTransition = key;\n        break;\n      }\n    }\n\n    transitionSupportChecked = true;\n  };\n\n  this.animate = function (element, properties, duration, easeMode, onComplete) {\n    for (var i = animations.length; i--;) {\n      if (animations[i].element === element) {\n        animations[i].cancel();\n        animations.splice(i, 1);\n      }\n    }\n\n    animations.push(new anim(element, properties, duration, easeMode, onComplete));\n  };\n\n  this.sendXhr = function (options) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          options.onSuccess(xhr.responseText);\n        } else if (options.onFailure) {\n          options.onFailure();\n        }\n      }\n    };\n\n    xhr.open('GET', options.url, true);\n    xhr.send(null);\n  };\n\n  this.calculateAngle = function (x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n  };\n\n  this.createSvgNode = function (name, attributes) {\n    var result = document.createElementNS('http://www.w3.org/2000/svg', name);\n    attributes = attributes || {};\n\n    for (var i in attributes) {\n      result.setAttributeNS(null, i, attributes[i]);\n    }\n\n    return result;\n  };\n\n  this.getSvgTextBBox = function (text, attributes) {\n    var svgElement = Piletilevi.venuemap.Utilities.createSvgNode('svg');\n    var node = Piletilevi.venuemap.Utilities.createSvgNode('text', attributes);\n    var textNode = document.createTextNode(text);\n    node.appendChild(textNode);\n    svgElement.appendChild(node);\n    document.body.appendChild(svgElement);\n    var result = node.getBBox();\n    document.body.removeChild(svgElement);\n    return result;\n  };\n\n  this.addClass = function (element, className) {\n    if (element) {\n      var elementClassName = element.getAttribute('class') || '';\n\n      if (-1 === elementClassName.indexOf(className)) {\n        if (elementClassName === '') {\n          element.setAttribute('class', className);\n        } else {\n          element.setAttribute('class', elementClassName + ' ' + className);\n        }\n      }\n    }\n  };\n\n  this.removeClass = function (element, className) {\n    if (element) {\n      var elementClassName = element.getAttribute('class') + '';\n\n      if (-1 !== elementClassName.indexOf(className)) {\n        if (-1 !== elementClassName.indexOf(className + ' ')) {\n          className += ' ';\n        } else if (-1 !== elementClassName.indexOf(' ' + className)) {\n          className = ' ' + className;\n        }\n\n        elementClassName = elementClassName.replace(className, '');\n        element.setAttribute('class', elementClassName);\n      }\n    }\n  };\n\n  this.isTransformSupported = function () {\n    return 'transform' in document.body.style;\n  };\n\n  this.getPosition = function (obj) {\n    var curleft = curtop = 0;\n\n    if (obj.offsetParent) {\n      do {\n        curleft += obj.offsetLeft;\n        curtop += obj.offsetTop;\n      } while (obj = obj.offsetParent);\n    }\n\n    return {\n      'x': curleft,\n      'y': curtop\n    };\n  };\n\n  this.getPageScroll = function () {\n    var xScroll, yScroll;\n\n    if (window.pageYOffset) {\n      yScroll = window.pageYOffset;\n      xScroll = window.pageXOffset;\n    } else if (document.documentElement && document.documentElement.scrollTop) {\n      yScroll = document.documentElement.scrollTop;\n      xScroll = document.documentElement.scrollLeft;\n    } else if (document.body) {\n      // all other Explorers\n      yScroll = document.body.scrollTop;\n      xScroll = document.body.scrollLeft;\n    }\n\n    return {\n      'x': xScroll,\n      'y': yScroll\n    };\n  };\n\n  this.createStretchHackElement = function (viewBox) {\n    var result = document.createElement('img');\n    result.src = 'data:image/svg+xml,%3Csvg viewBox=\\'' + viewBox + '\\' xmlns=\\'http://www.w3.org/2000/svg\\'/%3E';\n    result.style.width = '100%'; //result.style.height = '100%';\n\n    result.style.maxWidth = '100%';\n    result.style.maxHeight = '100%';\n    result.style.verticalAlign = 'top';\n    return result;\n  };\n}();\n\nPiletilevi.venuemap.VenueMap = function () {\n  var self = this;\n  var shopDomain = Piletilevi.venuemap.SHOP_DOMAIN;\n  var connectionSecure = false;\n  var confId = '';\n  var seatSelectionEnabled = false;\n  var seatsStatusDisplayed = false;\n  var seatDraggingEnabled = false;\n  var sectionsMapType = 'vector';\n  var currency = '';\n  var sectionsMapImageUrl = '';\n  var sections = [];\n  var enabledSections = [];\n  var selectedSeats = [];\n  var selectedSeatsIndex = {};\n  var eventHandlers = {};\n  var sectionsDetails = {};\n  var sectionsMap;\n  var placesMap;\n  var previousSection;\n  var activeSection;\n  var componentElement;\n  var zoomLevel = 0;\n  var translations = [];\n  var placeToolTip;\n  var built = false;\n  var displayed = true;\n  var inactiveSeatsNumbered = false;\n  var lastLoadedVenueConf = 0;\n  var lastLoadedVenueSuccessful = false;\n  var lastLoadedPlacesConf = 0;\n  var lastLoadedPlacesSuccessful = false;\n  var withControls = false;\n  var extensionHandler;\n  var seatsSections = {};\n  var requestCache = {};\n  var canvasFactory;\n  var extended = false;\n  var massSelectable = false;\n  var placesMapFlipped = false;\n  var legendType = 'price';\n  var concertId = ''; // temporary solution 0004087\n\n  var loadingOverrides = false; // temporary solution 0004087\n\n  var configOverrides = {}; // temporary solution 0004087\n\n  var zoomLimit = 16; // max seat radius in pixels\n\n  var placesMapData;\n  var placesMapAvailableSections = {};\n  var fullMapGenerated = false;\n  var fixedHeight = 0;\n  this.displayMapInPlaces = false;\n  var seatColors = {\n    'hover': Piletilevi.venuemap.DEFAULT_SEAT_HOVER_COLOR,\n    'active': Piletilevi.venuemap.DEFAULT_SEAT_ACTIVE_COLOR,\n    'inactive': Piletilevi.venuemap.DEFAULT_SEAT_INACTIVE_COLOR\n  };\n\n  var init = function init() {\n    componentElement = document.createElement('div');\n    componentElement.className = 'piletilevi_venue_map';\n    componentElement.style.display = 'none';\n    componentElement.style['-moz-user-select'] = 'none';\n    componentElement.style['-ms-user-select'] = 'none';\n    componentElement.style['-webkit-user-select'] = 'none';\n    componentElement.style.userSelect = 'none';\n    canvasFactory = new Piletilevi.venuemap.VenuePlacesMapCanvasFactory(self);\n    self.hide();\n    window.addEventListener('resize', self.resize);\n  };\n\n  var adjustToZoom = function adjustToZoom(withAnimation, focalPoint) {\n    adjustZoomControls();\n\n    if (activeSection || sectionsMapType === 'full_venue') {\n      placesMap.adjustToZoom(withAnimation, focalPoint);\n    } else if (sectionsMap) {//sectionsMap.position(); // broken\n    }\n  };\n\n  this.build = function () {\n    if (sectionsMapType !== 'full_venue') {\n      sectionsMap = new Piletilevi.venuemap.SectionsMap(self);\n      componentElement.appendChild(sectionsMap.getComponentElement());\n    }\n\n    placesMap = new Piletilevi.venuemap.PlacesMap(self);\n    componentElement.appendChild(placesMap.getComponentElement());\n    placeToolTip = new Piletilevi.venuemap.PlaceTooltip(self);\n    built = true;\n\n    if (concertId) {\n      // temporary solution 0004087\n      loadOverrides();\n    } else {\n      self.update();\n    }\n  };\n\n  var loadOverrides = function loadOverrides() {\n    // temporary solution 0004087\n    loadingOverrides = true;\n    self.requestShopData('/public/seatingPlanOverrides', function (response) {\n      configOverrides = null;\n\n      try {\n        configOverrides = JSON.parse(response);\n      } catch (error) {\n        console.error('Failed parsing config overrides response');\n        return;\n      }\n\n      if (_typeof(configOverrides) != 'object') {\n        console.error('Received invalid config overrides response');\n        return;\n      }\n\n      loadingOverrides = false;\n      self.update();\n    }, function () {\n      console.error('Failed loading config overrides');\n    });\n  };\n\n  var loadVenuePlacesMap = function loadVenuePlacesMap(onSuccess, onFail) {\n    if (lastLoadedPlacesConf === confId) {\n      if (lastLoadedPlacesSuccessful) {\n        onSuccess();\n      } else {\n        onFail();\n      }\n\n      return;\n    }\n\n    lastLoadedPlacesConf = confId;\n    self.requestShopData('/public/upload/seatingplan_json/' + confId + '.json', function (response) {\n      receiveVenuePlacesMap(response);\n      lastLoadedPlacesSuccessful = true;\n      self.trigger('placesMapLoadSuccess');\n      onSuccess();\n    }, function () {\n      onFail();\n      lastLoadedPlacesSuccessful = false;\n      self.trigger('placesMapLoadFailure');\n    }, false);\n  };\n\n  var receiveVenuePlacesMap = function receiveVenuePlacesMap(response) {\n    placesMapData = JSON.parse(response);\n    placesMapAvailableSections = {};\n\n    for (var i = 0; i < placesMapData.seats.length; ++i) {\n      var seat = placesMapData.seats[i];\n      placesMapAvailableSections[seat.section] = true;\n    }\n  };\n\n  var loadVenueMap = function loadVenueMap(onSuccess, onFail) {\n    if (lastLoadedVenueConf === confId) {\n      if (lastLoadedVenueSuccessful) {\n        onSuccess();\n      } else {\n        onFail();\n      }\n\n      return;\n    }\n\n    lastLoadedVenueConf = confId;\n\n    if (sectionsMapType === 'image') {\n      sectionsMap.createImageElement(sectionsMapImageUrl);\n      onSuccess();\n    } else {\n      self.requestShopData('/public/upload/seatingplan_svg/' + confId + '.svg', function (response) {\n        onSuccess();\n        lastLoadedVenueSuccessful = true;\n        receiveVenueMap(response);\n      }, function () {\n        onFail();\n        lastLoadedVenueSuccessful = false;\n        self.trigger('sectionsMapLoadFailure');\n      });\n    }\n  };\n\n  var receiveVenueMap = function receiveVenueMap(response) {\n    var mapData = response;\n    var parser = new DOMParser();\n\n    try {\n      var svgDocument = parser.parseFromString(mapData, 'image/svg+xml');\n\n      if (svgDocument && svgDocument.getElementsByTagName('parsererror').length > 0) {\n        svgDocument = null;\n      }\n\n      if (svgDocument) {\n        var elements = svgDocument.getElementsByTagName('image');\n        var protocol = connectionSecure ? 'https' : 'http';\n        var hrefBase = protocol + '://' + shopDomain;\n\n        for (var i = elements.length; i--;) {\n          elements[i].setAttribute('xlink:href', hrefBase + elements[i].getAttribute('xlink:href'));\n        }\n\n        sectionsMap.mapElement = document.adoptNode(svgDocument.documentElement);\n        sectionsMap.mapElement.style.verticalAlign = 'top';\n        sectionsMap.checkMapElement();\n      }\n    } catch (e) {}\n  };\n\n  var adjustZoomControls = function adjustZoomControls() {\n    placesMap.adjustZoomControls();\n  };\n\n  var moveSectionsMapToPlaces = function moveSectionsMapToPlaces() {\n    var sectionsThumbnailElement = placesMap.getSectionsThumbnailElement();\n    var sectionsMapElement = sectionsMap.getComponentElement();\n    sectionsThumbnailElement.insertBefore(sectionsMapElement, sectionsThumbnailElement.firstChild);\n  };\n\n  var moveSectionsMapToSections = function moveSectionsMapToSections() {\n    var sectionsMapElement = sectionsMap.getComponentElement();\n    componentElement.appendChild(sectionsMapElement);\n  };\n\n  this.update = function () {\n    if (loadingOverrides) {\n      // temporary solution 0004087\n      return;\n    }\n\n    if (!built) {\n      self.build();\n      return;\n    }\n\n    if (concertId && configOverrides[concertId]) {\n      // temporary solution 0004087\n      confId = configOverrides[concertId];\n    }\n\n    if (sectionsMapType !== 'full_venue') {\n      var regions = sectionsMap.getMapRegions();\n\n      if (activeSection) {\n        if (self.displayMapInPlaces) {\n          sectionsMap.display();\n          moveSectionsMapToPlaces();\n\n          if (typeof regions[activeSection] !== 'undefined') {\n            regions[activeSection].markActivePermanently();\n\n            for (var sectionId in regions) {\n              if (sectionId !== activeSection) {\n                regions[sectionId].markInactivePermanently();\n              }\n            }\n          }\n        } else {\n          sectionsMap.hide();\n        }\n\n        placesMap.setDisplayed(true);\n        var sectionDetails = self.getSectionDetails(activeSection);\n        placesMap.updateSectionDetails(sectionDetails);\n\n        if (activeSection === previousSection) {\n          return;\n        }\n\n        previousSection = activeSection;\n        self.hide();\n        self.setCurrentZoomLevel(0);\n        loadVenuePlacesMap(function () {\n          if (!placesMapAvailableSections[activeSection]) {\n            self.hide();\n            return;\n          }\n\n          placesMap.setDisplayed(true);\n          self.display();\n          var canvas = canvasFactory.createCanvas({\n            data: placesMapData,\n            relevantSections: [activeSection]\n          });\n          placesMap.changeCanvas(canvas);\n        }, function () {\n          self.hide();\n        });\n      } else {\n        if (self.displayMapInPlaces) {\n          moveSectionsMapToSections();\n\n          for (var _sectionId in regions) {\n            regions[_sectionId].unLockActive();\n\n            regions[_sectionId].refreshStatus();\n          }\n        }\n\n        self.setCurrentZoomLevel(0);\n        previousSection = 0;\n        placesMap.setDisplayed(false);\n        sectionsMap.update();\n        sectionsMap.display();\n        loadVenueMap(function () {\n          self.display();\n        }, function () {\n          self.hide();\n        });\n      }\n    } else {\n      placesMap.updateSectionsDetails(sectionsDetails);\n\n      if (fullMapGenerated) {\n        return;\n      }\n\n      loadVenuePlacesMap(function () {\n        placesMap.setDisplayed(true);\n        self.display();\n        var canvas = canvasFactory.createCanvas({\n          data: placesMapData,\n          relevantSections: enabledSections,\n          withStage: true\n        });\n        placesMap.changeCanvas(canvas);\n        fullMapGenerated = true;\n      }, function () {\n        self.hide();\n      });\n    }\n  };\n\n  this.display = function () {\n    if (displayed) {\n      return;\n    }\n\n    componentElement.style.display = '';\n    displayed = true;\n    self.resize();\n    self.trigger('visibilityChange', displayed);\n  };\n\n  this.hide = function () {\n    if (!displayed) {\n      return;\n    }\n\n    componentElement.style.display = 'none';\n    displayed = false;\n    self.trigger('visibilityChange', displayed);\n  };\n\n  this.setConfId = function (newConfId) {\n    confId = newConfId;\n  };\n\n  this.setConcertId = function (newConcertId) {\n    // temporary solution 0004087\n    concertId = newConcertId;\n  };\n\n  this.getConfId = function () {\n    return confId;\n  };\n\n  this.getZoomLimit = function () {\n    return zoomLimit;\n  };\n\n  this.setZoomLimit = function (newZoomLimit) {\n    zoomLimit = newZoomLimit;\n  };\n\n  this.getSectionsMap = function () {\n    return sectionsMap;\n  };\n\n  this.setSectionsMapType = function (newMapType) {\n    sectionsMapType = newMapType;\n  };\n\n  this.getSectionsMapType = function () {\n    return sectionsMapType;\n  };\n\n  this.setSectionsMapImageUrl = function (newMapImageUrl) {\n    sectionsMapImageUrl = newMapImageUrl;\n  };\n\n  this.getSectionsMapImageUrl = function () {\n    return sectionsMapImageUrl;\n  };\n\n  this.setSections = function (newSections) {\n    sections = newSections;\n  };\n\n  this.getSections = function () {\n    return sections;\n  };\n\n  this.setEnabledSections = function (newEnabledSections) {\n    enabledSections = newEnabledSections;\n  };\n\n  this.getEnabledSections = function () {\n    return enabledSections;\n  };\n\n  this.setSeatSelectionEnabled = function (newSeatSelectionEnabled) {\n    seatSelectionEnabled = newSeatSelectionEnabled;\n  };\n\n  this.setSeatDraggingEnabled = function (newSeatDraggingEnabled) {\n    seatDraggingEnabled = newSeatDraggingEnabled;\n  };\n\n  this.isSeatDraggingEnabled = function () {\n    return seatDraggingEnabled;\n  };\n\n  this.isSeatSelectionEnabled = function () {\n    return seatSelectionEnabled;\n  };\n\n  this.enableSeatsStatusDisplaying = function (newSeatStatusDisplayed) {\n    seatsStatusDisplayed = newSeatStatusDisplayed;\n  };\n\n  this.isSeatsStatusDisplayed = function () {\n    return seatsStatusDisplayed;\n  };\n\n  this.addSectionDetails = function (details) {\n    sectionsDetails[details.id] = details;\n\n    for (var i = details.seatsInfo.length; i--;) {\n      var seat = details.seatsInfo[i];\n      seatsSections[seat.id] = details;\n    }\n  };\n\n  this.getSectionDetails = function (id) {\n    return sectionsDetails[id] || null;\n  };\n\n  this.setSelectedSeats = function (newSelectedSeats) {\n    selectedSeats = newSelectedSeats;\n\n    for (var i = selectedSeats.length; i--;) {\n      selectedSeatsIndex[selectedSeats[i]] = true;\n    }\n  };\n\n  this.unSetSelectedSeats = function (unSelectedSeats) {\n    for (var i = unSelectedSeats.length; i--;) {\n      selectedSeatsIndex[unSelectedSeats[i]] = false;\n    }\n  };\n\n  this.unSelectSeat = function (seatId) {\n    selectedSeatsIndex[seatId] = false;\n  };\n\n  this.setSeatColors = function (newColors) {\n    seatColors.hover = newColors.hover || Piletilevi.venuemap.DEFAULT_SEAT_HOVER_COLOR;\n    seatColors.active = newColors.active || Piletilevi.venuemap.DEFAULT_SEAT_ACTIVE_COLOR;\n    seatColors.inactive = newColors.inactive || Piletilevi.venuemap.DEFAULT_SEAT_INACTIVE_COLOR;\n  };\n\n  this.getSeatColor = function (state) {\n    return seatColors[state];\n  };\n\n  this.isSeatSelected = function (seatId) {\n    return selectedSeatsIndex[seatId] || false;\n  };\n\n  this.getSectionBySeatId = function (seatId) {\n    return seatsSections[seatId] || null;\n  };\n\n  this.addHandler = function (eventName, callBack) {\n    if (typeof eventHandlers[eventName] == 'undefined') {\n      eventHandlers[eventName] = [];\n    }\n\n    eventHandlers[eventName].push(callBack);\n  };\n\n  this.trigger = function (event, param) {\n    for (var type in eventHandlers) {\n      if (type !== event) {\n        continue;\n      }\n\n      for (var i = eventHandlers[type].length; i--;) {\n        var handler = eventHandlers[type][i];\n        handler(param);\n      }\n\n      break;\n    }\n  };\n\n  this.setSelectedSection = function (sectionId) {\n    activeSection = sectionId;\n\n    if (placesMap && sectionsMapType === 'full_venue') {\n      placesMap.selectSection(sectionId);\n    }\n  };\n\n  this.setShopDomain = function (newShopDomain) {\n    shopDomain = newShopDomain;\n  };\n\n  this.setConnectionSecure = function (newConnectionSecure) {\n    connectionSecure = newConnectionSecure;\n  };\n\n  this.isConnectionSecure = function () {\n    return connectionSecure;\n  };\n\n  this.getShopDomain = function () {\n    return shopDomain;\n  };\n\n  this.getSelectedSection = function () {\n    return activeSection;\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  this.zoomIn = function () {\n    ++zoomLevel;\n    adjustToZoom();\n  };\n\n  this.zoomOut = function () {\n    --zoomLevel >= 0 || (zoomLevel = 0);\n    adjustToZoom();\n  };\n\n  this.setZoomLevel = function (newZoom, withAnimation, focalPoint) {\n    zoomLevel = newZoom;\n    adjustToZoom(withAnimation, focalPoint);\n  };\n\n  this.setCurrentZoomLevel = function (currentZoom) {\n    zoomLevel = currentZoom;\n    adjustZoomControls();\n  };\n\n  this.resize = function () {\n    var dupe = componentElement.cloneNode(false);\n    dupe.style.visibility = 'hidden';\n    dupe.style.display = 'block';\n    componentElement.parentNode.appendChild(dupe);\n    fixedHeight = dupe.offsetHeight;\n    componentElement.parentNode.removeChild(dupe);\n\n    if (placesMap) {\n      placesMap.resize();\n    }\n  };\n\n  this.getFixedHeight = function () {\n    return fixedHeight;\n  };\n\n  this.getZoomLevel = function () {\n    return zoomLevel;\n  };\n\n  this.addTranslation = function (key, value) {\n    translations[key] = value;\n  };\n\n  this.getTranslation = function (key) {\n    if (translations[key]) {\n      return translations[key];\n    } else {\n      return key;\n    }\n  };\n\n  this.getPlaceToolTip = function () {\n    return placeToolTip;\n  };\n\n  this.requestShopData = function (path, _onSuccess, onFail, withCacheWorkaround) {\n    if (typeof requestCache[path] !== 'undefined') {\n      if (requestCache[path] === false) {\n        onFail();\n      } else {\n        _onSuccess(requestCache[path]);\n      }\n\n      return;\n    }\n\n    var protocol = connectionSecure ? 'https' : 'http';\n    var requestDomain = shopDomain;\n\n    if (path.indexOf('seatingPlanOverrides') >= 0) {\n      requestDomain = Piletilevi.venuemap.SHOP_DOMAIN;\n    }\n\n    if (requestDomain === Piletilevi.venuemap.SHOP_DOMAIN) {\n      // http would get redirected\n      protocol = 'https';\n    }\n\n    var url = protocol + '://' + requestDomain + path;\n\n    if (withCacheWorkaround) {\n      var date = new Date();\n      url += '?' + date.getTime();\n    }\n\n    Piletilevi.venuemap.Utilities.sendXhr({\n      'url': url,\n      'onSuccess': function onSuccess(response) {\n        requestCache[path] = response;\n\n        _onSuccess(response);\n      },\n      'onFailure': function onFailure() {\n        requestCache[path] = false;\n        onFail();\n      }\n    });\n  };\n\n  this.areInactiveSeatsNumbered = function () {\n    return inactiveSeatsNumbered;\n  };\n\n  this.setInactiveSeatsNumbered = function (enabled) {\n    inactiveSeatsNumbered = !!enabled;\n  };\n\n  this.getWithControls = function () {\n    return withControls;\n  };\n\n  this.setWithControls = function (enabled) {\n    withControls = !!enabled;\n  };\n\n  this.getExtensionHandler = function () {\n    return extensionHandler;\n  };\n\n  this.setExtensionHandler = function (input) {\n    extensionHandler = input;\n  };\n\n  this.getLegendType = function () {\n    return legendType;\n  };\n\n  this.setLegendType = function (input) {\n    legendType = input;\n  };\n\n  this.isMassSelectable = function () {\n    return massSelectable;\n  };\n\n  this.setMassSelectable = function (input) {\n    massSelectable = !!input;\n  };\n\n  this.isPlacesMapFlipped = function () {\n    return placesMapFlipped;\n  };\n\n  this.setPlacesMapFlipped = function (input) {\n    placesMapFlipped = input && Piletilevi.venuemap.Utilities.isTransformSupported();\n  };\n\n  this.setCurrency = function (input) {\n    currency = input;\n  };\n\n  this.getCurrency = function () {\n    return currency;\n  };\n\n  this.extend = function () {\n    if (!extensionHandler) {\n      return;\n    }\n\n    extended = !extended;\n    extensionHandler();\n    var extensionClass = 'piletilevi_venue_map_extended';\n\n    if (extended) {\n      Piletilevi.venuemap.Utilities.addClass(componentElement, extensionClass);\n    } else {\n      Piletilevi.venuemap.Utilities.removeClass(componentElement, extensionClass);\n    }\n  };\n\n  this.dispose = function () {\n    if (componentElement && componentElement.parentNode) {\n      componentElement.parentNode.removeChild(componentElement);\n    }\n\n    componentElement = null;\n\n    if (placeToolTip) {\n      placeToolTip.dispose();\n    }\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.DragTicketsPositioner = function () {\n  var nearSeatIndex;\n  var stickToIndex;\n  var STATUS_AVAILABLE = 1;\n\n  this.findNewSeats = function (nearSeat, selectedSeats, details) {\n    var checkedIndexes = null;\n    var amount = selectedSeats.length; //are some places selected at all\n\n    if (!amount) {\n      return false;\n    } //do we have seats in section?\n\n\n    if (typeof details.seatsInfo === 'undefined') {\n      return false;\n    }\n\n    var row = gatherRowSeats(details.seatsInfo, nearSeat); //if row has been found\n\n    if (!row) {\n      return false;\n    }\n\n    checkedIndexes = checkFromStart(nearSeatIndex, row, amount);\n\n    if (!stickToIndex) {\n      checkedIndexes = checkFromEnd(nearSeatIndex, row, amount);\n    }\n\n    var result = [];\n    checkedIndexes.map(function (item, index) {\n      result.push(row[index]);\n    });\n    return result;\n  };\n\n  var checkFromStart = function checkFromStart(nearSeatIndex, row, amount) {\n    var checkedIndexes = []; //take row boundaries into account\n\n    var startIndex = Math.max(nearSeatIndex - amount, 0); //start from \"left\" go to right searching for free places\n\n    for (var seatIndex = startIndex; seatIndex < nearSeatIndex + amount; seatIndex++) {\n      //previous place doesnt exist, we should stick to it\n      if (typeof row[seatIndex - 1] === 'undefined') {\n        stickToIndex = seatIndex;\n      } else if (row[seatIndex - 1].status !== STATUS_AVAILABLE) {\n        stickToIndex = seatIndex;\n      }\n\n      var checkAmount = amount; //now check all forward seats to find whether they are all free for taking\n\n      do {\n        //if place is not free or doesnt exist\n        //then go out and check next chain of seats\n        if (typeof row[seatIndex] === 'undefined' || row[seatIndex].status !== STATUS_AVAILABLE) {\n          stickToIndex = false;\n          break;\n        }\n\n        checkedIndexes.push(seatIndex);\n        seatIndex++;\n      } while (--checkAmount); //if we found needed chain of free seats from this direction then go out\n\n\n      if (checkedIndexes.length === amount) {\n        break;\n      }\n    }\n\n    return checkedIndexes;\n  };\n\n  var checkFromEnd = function checkFromEnd(nearSeatIndex, row, amount) {\n    var checkedIndexes = []; //take row boundaries into account\n\n    var startIndex = Math.min(nearSeatIndex + amount, row.length - 1); //start from \"left\" go to right searching for free places\n\n    for (var seatIndex = startIndex; seatIndex >= 0; seatIndex--) {\n      //previous place doesnt exist, we should stick to it\n      if (typeof row[seatIndex + 1] === 'undefined') {\n        stickToIndex = seatIndex;\n      } else if (row[seatIndex + 1].status !== STATUS_AVAILABLE) {\n        stickToIndex = seatIndex;\n      }\n\n      var checkAmount = amount; //now check all forward seats to find whether they are all free for taking\n\n      do {\n        //if place is not free or doesnt exist\n        //then go out and check next chain of seats\n        if (typeof row[seatIndex] === 'undefined' || row[seatIndex].status !== STATUS_AVAILABLE) {\n          stickToIndex = false;\n          break;\n        }\n\n        checkedIndexes.push(seatIndex);\n        seatIndex--;\n      } while (--checkAmount); //if we found needed chain of free seats from this direction then go out\n\n\n      if (checkedIndexes.length === amount) {\n        break;\n      }\n    }\n\n    return checkedIndexes;\n  };\n\n  var gatherRowSeats = function gatherRowSeats(seatsInfo, nearSeat) {\n    var row = []; //gather seats from same row into one array\n\n    for (var i = 0; i < seatsInfo.length; i++) {\n      var seat = seatsInfo[i];\n\n      if (seat.row === nearSeat.row) {\n        if (seat === nearSeat) {\n          nearSeatIndex = row.length;\n        }\n\n        row.push(seat);\n      }\n    }\n\n    return row;\n  };\n};\n\nPiletilevi.venuemap.Controls = function (venueMap) {\n  var self = this;\n  var CLASS_ACTIVE = 'piletilevi_venue_map_control_active';\n  var buttonElements = {};\n  var handlers = {\n    extend: function extend(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      venueMap.extend();\n    },\n    zoomin: function zoomin(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      venueMap.zoomIn();\n    },\n    zoomout: function zoomout(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      venueMap.zoomOut();\n    },\n    resetzoom: function resetzoom(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      venueMap.setZoomLevel(0);\n    }\n  };\n  var componentElement;\n\n  var init = function init() {\n    createDomStructure();\n  };\n\n  var createDomStructure = function createDomStructure() {\n    componentElement = document.createElement('div');\n    componentElement.className = 'piletilevi_venue_map_controls';\n\n    if (venueMap.getExtensionHandler()) {\n      createButton('extend');\n    }\n\n    createButton('zoomin');\n    createButton('zoomout');\n    createButton('resetzoom');\n    self.changeStates({\n      extend: true\n    });\n  };\n\n  var createButton = function createButton(type) {\n    var buttonElement = document.createElement('div');\n    buttonElement.className = 'piletilevi_venue_map_control piletilevi_venue_map_control_' + type;\n    componentElement.appendChild(buttonElement);\n    buttonElements[type] = buttonElement;\n    return buttonElement;\n  };\n\n  this.changeStates = function (changes) {\n    for (var key in changes) {\n      if (changes.hasOwnProperty(key)) {\n        var button = buttonElements[key];\n\n        if (!button) {\n          continue;\n        }\n\n        if (changes[key]) {\n          Piletilevi.venuemap.Utilities.addClass(button, CLASS_ACTIVE);\n          button.addEventListener('click', handlers[key], true);\n        } else {\n          Piletilevi.venuemap.Utilities.removeClass(button, CLASS_ACTIVE);\n          button.removeEventListener('click', handlers[key], true);\n        }\n      }\n    }\n  };\n\n  this.setVisible = function (visible) {\n    componentElement.style.display = visible ? 'block' : 'none';\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.SectionsMap = function (venueMap) {\n  var mapRegions = {};\n  this.imageElement = false;\n  this.mapElement = false;\n  this.vectorDocument = false;\n  var componentElement;\n  var stretchElement;\n  var self = this;\n\n  var init = function init() {\n    componentElement = document.createElement('div');\n    componentElement.className = 'piletilevi_venue_map_sections';\n  };\n\n  this.update = function () {\n    var enabledSectionsIndex = {};\n    var enabledSections = venueMap.getEnabledSections();\n\n    for (var i = enabledSections.length; i--;) {\n      enabledSectionsIndex[enabledSections[i]] = true;\n    }\n\n    for (var key in mapRegions) {\n      mapRegions[key].setEnabled(key in enabledSectionsIndex);\n      mapRegions[key].refreshStatus();\n    }\n  };\n\n  this.display = function () {\n    componentElement.style.display = '';\n  };\n\n  this.hide = function () {\n    componentElement.style.display = 'none';\n  };\n\n  this.createImageElement = function (imageSource) {\n    if (self.imageElement) {\n      componentElement.removeChild(self.imageElement);\n    }\n\n    var element = document.createElement('img');\n    element.setAttribute('src', imageSource);\n    self.imageElement = element;\n    componentElement.appendChild(element);\n  };\n\n  this.checkMapElement = function () {\n    if (stretchElement) {\n      componentElement.removeChild(stretchElement);\n    }\n\n    if (self.mapElement) {\n      stretchElement = Piletilevi.venuemap.Utilities.createStretchHackElement(self.mapElement.getAttribute('viewBox'));\n      componentElement.appendChild(stretchElement);\n      componentElement.appendChild(self.mapElement);\n      self.vectorDocument = self.mapElement;\n      parseMapElement();\n      self.update();\n    }\n  };\n\n  var parseMapElement = function parseMapElement() {\n    if (self.mapElement && self.vectorDocument) {\n      var vectorDocument = self.vectorDocument;\n\n      for (var j = 0; j < vectorDocument.childNodes.length; j++) {\n        if (vectorDocument.childNodes[j].id) {\n          var sectionId = vectorDocument.childNodes[j].id.split('section')[1];\n          var sectionVector = vectorDocument.childNodes[j];\n\n          if (!mapRegions[sectionId]) {\n            mapRegions[sectionId] = new Piletilevi.venuemap.SectionsMapRegion(venueMap, self, sectionId, sectionVector);\n          }\n        }\n      }\n\n      self.mapElement.style.visibility = 'visible';\n    }\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  this.getMapRegions = function () {\n    return mapRegions;\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.SectionsMapRegion = function (venueMap, sectionsMap, id, sectionVector) {\n  var self = this;\n  var enabled = false;\n  var activeLocked = false;\n  this.id = false;\n\n  var init = function init() {\n    self.id = id;\n    sectionVector.addEventListener('click', self.click);\n    sectionVector.addEventListener('mouseover', self.mouseOver);\n    sectionVector.addEventListener('mouseout', self.mouseOut);\n  };\n\n  this.refreshStatus = function () {\n    if (!enabled) {\n      this.markDisabled();\n    } else {\n      this.markInactive();\n    }\n  };\n\n  this.mouseOver = function () {\n    self.markActive();\n    venueMap.trigger('sectionMouseover', id);\n  };\n\n  this.mouseOut = function () {\n    self.markInactive();\n    venueMap.trigger('sectionMouseout', id);\n  };\n\n  this.markDisabled = function () {\n    if (sectionVector) {\n      sectionVector.setAttribute('style', 'display: none;');\n    }\n  };\n\n  this.markActive = function () {\n    if (sectionVector && !activeLocked) {\n      sectionVector.setAttribute('fill', '#75bb01');\n      sectionVector.setAttribute('opacity', '0.8');\n      sectionVector.setAttribute('style', 'display: block;');\n    }\n  };\n\n  this.markInactive = function () {\n    if (sectionVector && !activeLocked) {\n      sectionVector.setAttribute('fill', '#cccccc');\n      sectionVector.setAttribute('opacity', '0');\n      sectionVector.setAttribute('style', 'display: block;');\n    }\n  };\n\n  this.markActivePermanently = function () {\n    self.markActive();\n    activeLocked = true;\n  };\n\n  this.markInactivePermanently = function () {\n    self.markInactive();\n    activeLocked = true;\n  };\n\n  this.unLockActive = function () {\n    activeLocked = false;\n    self.markInactive();\n  };\n\n  this.setEnabled = function (input) {\n    enabled = !!input;\n  };\n\n  this.isEnabled = function () {\n    return enabled;\n  };\n\n  this.click = function () {\n    venueMap.trigger('sectionSelected', id);\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.PlacesMap = function (venueMap) {\n  var self = this;\n  var sectionsThumbnailElement;\n  var legendElement;\n  var componentElement, mainElement;\n  var canvas;\n  var displayed = false;\n  var controls;\n  var selectionRectangle;\n  var details = {};\n  var pendingCanvasDetails = [];\n  var blockingOverlayElement;\n  var RSM_NONE = 0;\n  var RSM_WAITING = 1;\n  var RSM_IN_PROGRESS = 2;\n  var rectangleSelectionMode = RSM_NONE;\n  var seatsBeforeRectSelection = {};\n\n  var init = function init() {\n    createDomStructure();\n    mainElement.addEventListener('wheel', onWheel);\n\n    if (venueMap.isMassSelectable()) {\n      document.addEventListener('keydown', keydown);\n    }\n  };\n\n  var createDomStructure = function createDomStructure() {\n    componentElement = document.createElement('div');\n    componentElement.className = 'piletilevi_venue_map_places';\n    componentElement.style.display = 'none';\n    legendElement = document.createElement('div');\n    legendElement.className = 'places_map_legend';\n    componentElement.appendChild(legendElement);\n    sectionsThumbnailElement = document.createElement('div');\n    sectionsThumbnailElement.className = 'places_map_sections_thumbnail';\n    componentElement.appendChild(sectionsThumbnailElement);\n    var sectionsThumbnailOverflowElement = document.createElement('div');\n    sectionsThumbnailOverflowElement.className = 'places_map_sections_thumbnail_overflow';\n    sectionsThumbnailElement.appendChild(sectionsThumbnailOverflowElement);\n    mainElement = document.createElement('div');\n    mainElement.className = 'piletilevi_venue_map_places_main';\n    mainElement.style.position = 'relative';\n    mainElement.style.overflow = 'hidden';\n    blockingOverlayElement = document.createElement('div');\n    blockingOverlayElement.style.position = 'absolute';\n    blockingOverlayElement.style.left = '0';\n    blockingOverlayElement.style.right = '0';\n    blockingOverlayElement.style.top = '0';\n    blockingOverlayElement.style.bottom = '0';\n    blockingOverlayElement.style.display = 'none';\n    mainElement.appendChild(blockingOverlayElement);\n    componentElement.appendChild(mainElement);\n\n    if (venueMap.getWithControls()) {\n      controls = new Piletilevi.venuemap.Controls(venueMap);\n      mainElement.appendChild(controls.getComponentElement());\n      Piletilevi.venuemap.Utilities.addClass(componentElement, 'piletilevi_venue_map_places_with_controls');\n    }\n  };\n\n  this.getSectionsThumbnailElement = function () {\n    return sectionsThumbnailElement;\n  };\n\n  var keydown = function keydown(event) {\n    if (event.keyCode !== 17 || !canvas) // ctrl\n      {\n        return;\n      }\n\n    rectangleSelectionMode = RSM_WAITING;\n\n    if (controls) {\n      controls.setVisible(false);\n    }\n\n    canvas.disableDragging();\n    mainElement.style.cursor = 'crosshair';\n    blockingOverlayElement.style.display = 'block';\n    mainElement.addEventListener('mousedown', mousedown);\n    document.removeEventListener('keydown', keydown);\n    document.addEventListener('keyup', keyup);\n  };\n\n  var keyup = function keyup(event) {\n    if (event.keyCode !== 17) // ctrl\n      {\n        return;\n      }\n\n    endRectangleSelection();\n  };\n\n  var mousedown = function mousedown(event) {\n    mainElement.removeEventListener('mousedown', mousedown);\n    startRectangleSelection(getCursorOffset(event));\n  };\n\n  var mousemove = function mousemove(event) {\n    selectionRectangle.setOtherPoint(getCursorOffset(event));\n    var region = selectionRectangle.getRegion();\n    canvas.selectSeatsInRegion(region, seatsBeforeRectSelection);\n  };\n\n  var mouseup = function mouseup() {\n    endRectangleSelection();\n  };\n\n  var startRectangleSelection = function startRectangleSelection(cursorOffset) {\n    rectangleSelectionMode = RSM_IN_PROGRESS;\n    var selectedSeats = canvas.getSelectedSeats();\n    seatsBeforeRectSelection = {};\n\n    for (var i = selectedSeats.length; i--;) {\n      var info = selectedSeats[i].getSeatInfo();\n\n      if (info) {\n        seatsBeforeRectSelection[info.id] = true;\n      }\n    }\n\n    selectionRectangle = new Piletilevi.venuemap.SelectionRectangle(cursorOffset);\n    mainElement.appendChild(selectionRectangle.getComponentElement());\n    mainElement.addEventListener('mousemove', mousemove);\n    mainElement.addEventListener('mouseup', mouseup);\n  };\n\n  var endRectangleSelection = function endRectangleSelection() {\n    if (venueMap.getZoomLevel() > 0) {\n      canvas.enableDragging();\n    }\n\n    document.removeEventListener('keyup', keyup);\n    mainElement.removeEventListener('mousedown', mousedown);\n    mainElement.removeEventListener('mouseup', mouseup);\n    mainElement.removeEventListener('mousemove', mousemove);\n\n    if (selectionRectangle) {\n      mainElement.removeChild(selectionRectangle.getComponentElement());\n      selectionRectangle = null;\n    }\n\n    if (rectangleSelectionMode === RSM_IN_PROGRESS) {\n      var selectedSeatsIds = [];\n\n      var _selectedSeats = canvas.getSelectedSeats();\n\n      for (var i = _selectedSeats.length; i--;) {\n        var info = _selectedSeats[i].getSeatInfo();\n\n        if (info && !seatsBeforeRectSelection[info.id]) {\n          selectedSeatsIds.push(info.id);\n        }\n      }\n\n      if (selectedSeatsIds.length > 0) {\n        venueMap.trigger('seatsSelected', selectedSeatsIds);\n      }\n    }\n\n    rectangleSelectionMode = RSM_NONE;\n    document.addEventListener('keydown', keydown); // defer controls hiding and such, in case the key is still down and selection restarts\n\n    window.setTimeout(finalizeRectangleSelectionEnding, 100);\n  };\n\n  var finalizeRectangleSelectionEnding = function finalizeRectangleSelectionEnding() {\n    if (rectangleSelectionMode !== RSM_NONE) {\n      // selection restarted immeditely\n      return;\n    }\n\n    mainElement.style.cursor = '';\n    blockingOverlayElement.style.display = 'none';\n\n    if (controls) {\n      controls.setVisible(true);\n    }\n  };\n\n  var getCursorOffset = function getCursorOffset(mouseEvent) {\n    var elementOffset = Piletilevi.venuemap.Utilities.getPosition(mainElement);\n    return {\n      top: Math.max(0, mouseEvent.pageY - elementOffset.y),\n      left: Math.max(0, mouseEvent.pageX - elementOffset.x)\n    };\n  };\n\n  var onWheel = function onWheel(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n\n    event.returnValue = false;\n\n    if (rectangleSelectionMode !== RSM_NONE || event.deltaY === 0) {\n      return;\n    }\n\n    var e = event;\n    var rect = mainElement.getBoundingClientRect();\n    var x = e.pageX - rect.left - window.pageXOffset;\n    var y = e.pageY - rect.top - window.pageYOffset;\n    var scrollLocation = canvas.getPointRelativeToContainer(x, y);\n    var scrolledUp = event.deltaY < 0;\n    var zoom = venueMap.getZoomLevel();\n\n    if (scrolledUp) {\n      ++zoom;\n    } else {\n      --zoom;\n    }\n\n    var maxZoomLevel = canvas ? canvas.getMaxZoomLevel() : 0;\n\n    if (zoom >= 0 && zoom <= maxZoomLevel) {\n      venueMap.setZoomLevel(zoom, true, scrollLocation);\n    }\n  };\n\n  var priceFormatter = function priceFormatter(input) {\n    return input;\n  };\n\n  this.adjustZoomControls = function () {\n    if (!controls) {\n      return;\n    }\n\n    var maxZoom = canvas ? canvas.getMaxZoomLevel() : 0;\n    var currentZoom = venueMap.getZoomLevel();\n    var states = {\n      zoomin: currentZoom < maxZoom,\n      zoomout: currentZoom > 0,\n      resetzoom: currentZoom > 0\n    };\n    controls.changeStates(states);\n  };\n\n  this.changeCanvas = function (newCanvas) {\n    if (canvas) {\n      canvas.remove();\n    }\n\n    canvas = newCanvas;\n    canvas.attachTo(self);\n\n    for (var key in details) {\n      canvas.updateSectionDetails(details[key]);\n    }\n\n    pendingCanvasDetails = [];\n    canvas.setDisplayed(displayed);\n  };\n\n  this.updateSectionsDetails = function (sectionsDetails) {\n    var combinedPriceClasses = [];\n\n    for (var key in sectionsDetails) {\n      if (sectionsDetails.hasOwnProperty(key)) {\n        details[key] = sectionsDetails[key];\n        updateCanvasDetails(sectionsDetails[key]);\n        var priceClasses = sectionsDetails[key].priceClasses || [];\n        combinedPriceClasses = combinedPriceClasses.concat(priceClasses);\n      }\n    }\n\n    var index = {};\n\n    for (var i = 0; i < combinedPriceClasses.length;) {\n      var priceClass = combinedPriceClasses[i];\n\n      if (index[priceClass.id]) {\n        combinedPriceClasses.splice(i, 1);\n        continue;\n      }\n\n      index[priceClass.id] = true;\n      ++i;\n    }\n\n    updateLegend(combinedPriceClasses);\n  };\n\n  this.updateSectionDetails = function (newDetails) {\n    if (venueMap.displayMapInPlaces) {\n      domHelper.addClass(componentElement, 'piletilevi_venue_map_places_with_map');\n    }\n\n    if (!newDetails) {\n      return;\n    }\n\n    details[newDetails.id] = newDetails;\n    var priceClasses = newDetails.priceClasses || [];\n    updateLegend(priceClasses);\n    updateCanvasDetails(newDetails);\n  };\n\n  this.adjustToZoom = function (withAnimation, focalPoint) {\n    if (canvas) {\n      canvas.adjustToZoom(withAnimation, focalPoint);\n    }\n  };\n\n  this.resize = function () {\n    if (!displayed || !canvas) {\n      return;\n    }\n\n    if (canvas) {\n      canvas.resize();\n    }\n  };\n\n  this.getLegendHeight = function () {\n    var style = window.getComputedStyle(legendElement);\n    var margins = parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    return legendElement.offsetHeight + margins;\n  };\n\n  this.setDisplayed = function (newDisplayed) {\n    if (displayed === newDisplayed) {\n      return;\n    }\n\n    displayed = newDisplayed;\n\n    if (canvas) {\n      canvas.setDisplayed(true);\n    }\n\n    componentElement.style.display = displayed ? '' : 'none';\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  this.selectSection = function (sectionId) {\n    if (!canvas) {\n      return;\n    }\n\n    canvas.selectSection(sectionId);\n  };\n\n  var updateCanvasDetails = function updateCanvasDetails(sectionDetails) {\n    if (!canvas) {\n      return;\n    }\n\n    canvas.updateSectionDetails(sectionDetails);\n  };\n\n  var updateLegend = function updateLegend(priceClasses) {\n    var legendItem;\n\n    while (legendElement.firstChild) {\n      legendElement.removeChild(legendElement.firstChild);\n    }\n\n    var legendType = venueMap.getLegendType();\n    var displayed = legendType === 'price' || legendType === 'title';\n    legendElement.style.display = displayed ? 'block' : 'none';\n\n    if (!displayed) {\n      return;\n    }\n\n    var label = venueMap.getTranslation('booked');\n    legendItem = new Piletilevi.venuemap.PlaceMapLegendItem(label, venueMap.getSeatColor('inactive'), 'booked');\n    legendElement.appendChild(legendItem.getComponentElement());\n    var sorter = legendType === 'price' ? function (a, b) {\n      return parseFloat(a.price) - parseFloat(b.price);\n    } : function (a, b) {\n      return a.title.localeCompare(b.title);\n    };\n    priceClasses.sort(sorter);\n\n    for (var i = 0; i < priceClasses.length; i++) {\n      if (priceClasses[i][legendType]) {\n        legendItem = new Piletilevi.venuemap.PlaceMapLegendItem(priceFormatter(priceClasses[i][legendType]), priceClasses[i].color, '', venueMap.getCurrency());\n        legendElement.appendChild(legendItem.getComponentElement());\n      }\n    }\n  };\n\n  this.getMainElement = function () {\n    return mainElement;\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.SelectionRectangle = function (anchorPoint) {\n  var otherPoint;\n  var style;\n  var region;\n  var componentElement;\n\n  var init = function init() {\n    componentElement = document.createElement('div');\n    componentElement.className = 'piletilevi_venuemap_selection_rectangle';\n    style = componentElement.style;\n    style.position = 'absolute';\n    style.borderWidth = '1px';\n    region = {\n      top: anchorPoint.top,\n      left: anchorPoint.left,\n      width: 0,\n      height: 0\n    };\n    applyRegionStyle();\n  };\n\n  this.setOtherPoint = function (_otherPoint) {\n    otherPoint = _otherPoint;\n    region = {\n      top: Math.min(anchorPoint.top, otherPoint.top),\n      left: Math.min(anchorPoint.left, otherPoint.left),\n      width: Math.abs(anchorPoint.left - otherPoint.left),\n      height: Math.abs(anchorPoint.top - otherPoint.top)\n    };\n    applyRegionStyle();\n  };\n\n  var applyRegionStyle = function applyRegionStyle() {\n    for (var key in region) {\n      if (region.hasOwnProperty(key)) {\n        style[key] = region[key] + 'px';\n      }\n    }\n  };\n\n  this.getRegion = function () {\n    return region;\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.PlacesMapCanvas = function (venueMap, svgElement, sectionLabelElements) {\n  var self = this;\n  var placesIndex = {};\n  var componentElement;\n  var displayed = false;\n  var aspectRatio;\n  var svgDimensions = {\n    width: 0,\n    height: 0\n  };\n  var containerElement;\n  var boundariesPadding = 0;\n  var sectionsBoundaries = {};\n  var lastZoomlevel = -1;\n  var sectionZoomSeatRadius = 8;\n  var seatNumbersRequirement = 7;\n  var sectionLabelsRequirement = 2.9;\n  var sectionLabelSize = 14;\n  var zoomFactor = 1.25;\n  var touchScalingPoint;\n  var containerDimensions;\n  var containerInnerDimensions;\n  var maxZoomLevel = 0;\n  var maxZoomWidth = 0;\n  var container;\n\n  var init = function init() {\n    sectionLabelElements = sectionLabelElements || {};\n    componentElement = document.createElement('div');\n    componentElement.className = 'piletilevi_venue_map_canvas';\n    componentElement.style.overflow = 'hidden';\n    componentElement.style.position = 'relative';\n    componentElement.style.textAlign = 'center';\n    componentElement.style.display = 'none';\n\n    if (venueMap.isPlacesMapFlipped()) {\n      componentElement.style.transform = 'rotate(180deg)';\n    }\n\n    svgElement.style.verticalAlign = 'middle';\n    svgElement.style.position = 'relative';\n    var viewBox = svgElement.getAttribute('viewBox').split(' ');\n    svgDimensions.width = +viewBox[2];\n    svgDimensions.height = +viewBox[3];\n    aspectRatio = svgDimensions.width / svgDimensions.height;\n    var elements = svgElement.querySelectorAll('.place');\n\n    if (!elements.length) {\n      elements = svgElement.querySelectorAll('circle');\n    }\n\n    for (var i = elements.length; i--;) {\n      var element = elements[i];\n      var id = element.id;\n\n      if (id.indexOf('place_') === 0) {\n        id = id.substring(6);\n      }\n\n      if (!id) {\n        continue;\n      }\n\n      if (!placesIndex[id]) {\n        placesIndex[id] = new Piletilevi.venuemap.PlacesMapPlace(venueMap, element);\n      }\n    }\n\n    componentElement.appendChild(svgElement);\n    var arrowTextElement;\n\n    if (arrowTextElement = svgElement.getElementById('stagename')) {\n      new Piletilevi.venuemap.PlacesMapStageLabel(venueMap, arrowTextElement);\n    }\n  };\n\n  this.attachTo = function (destination) {\n    container = destination;\n    containerElement = container.getMainElement();\n\n    if (containerElement.firstChild) {\n      containerElement.insertBefore(componentElement, containerElement.firstChild);\n    } else {\n      containerElement.appendChild(componentElement);\n    }\n\n    self.registerDraggableElement({\n      'draggableElement': componentElement,\n      'gestureElement': componentElement,\n      'boundariesElement': containerElement,\n      'boundariesPadding': boundariesPadding\n    });\n  };\n\n  this.remove = function () {\n    self.unRegisterScalableElement();\n    self.disableDragging();\n\n    if (componentElement.parentNode) {\n      componentElement.parentNode.removeChild(componentElement);\n    }\n  };\n\n  var scaleStartCallback = function scaleStartCallback(info) {\n    var rect = containerElement.getBoundingClientRect();\n    var touchPosition = {\n      x: (info.startF0x + info.startF1x) / 2 - rect.left - window.pageXOffset,\n      y: (info.startF0y + info.startF1y) / 2 - rect.top - window.pageYOffset\n    };\n    touchScalingPoint = self.getPointRelativeToContainer(touchPosition.x, touchPosition.y);\n    return true;\n  };\n\n  var scaleChangeCallback = function scaleChangeCallback(info) {\n    var scaledPosition = getScaledMapPosition(info.currentWidth, info.currentHeight, touchScalingPoint);\n    componentElement.style.left = scaledPosition.x + 'px';\n    componentElement.style.top = scaledPosition.y + 'px';\n  };\n\n  var scaleEndCallback = function scaleEndCallback() {\n    lastZoomlevel = calculateZoomLevelFromMapWidth(componentElement.offsetWidth);\n    venueMap.setCurrentZoomLevel(lastZoomlevel);\n    zoomAdjusted();\n  };\n\n  var calculateZoomLevelFromMapWidth = function calculateZoomLevelFromMapWidth(zoomedWidth) {\n    var scale = zoomedWidth / containerDimensions.width;\n    return Math.round(Math.log(scale) / Math.log(zoomFactor));\n  };\n\n  var calculateMaxZoomLevel = function calculateMaxZoomLevel() {\n    var maxSeatRadius = venueMap.getZoomLimit();\n    var diff = maxSeatRadius / Piletilevi.venuemap.SEAT_CIRCLE_RADIUS;\n    maxZoomWidth = svgDimensions.width * diff;\n    var paddings = getPaddings();\n    maxZoomWidth += paddings.left + paddings.right;\n    maxZoomLevel = Math.max(0, calculateZoomLevelFromMapWidth(maxZoomWidth));\n  };\n\n  this.getMaxZoomLevel = function () {\n    return maxZoomLevel;\n  };\n\n  this.updateSectionDetails = function (sectionDetails) {\n    if (!sectionDetails) {\n      return;\n    }\n\n    if (sectionLabelElements[sectionDetails.id]) {\n      self.setTextContent(sectionLabelElements[sectionDetails.id], sectionDetails.title);\n    }\n\n    var priceClasses = sectionDetails.priceClasses || [];\n    var priceClassesIndex = {};\n\n    for (var i = priceClasses.length; i--;) {\n      priceClassesIndex[priceClasses[i].id] = priceClasses[i];\n    }\n\n    var seatsManuallySelectable = venueMap.isSeatSelectionEnabled() && sectionDetails.selectableSeats;\n    var seatsInfo = sectionDetails.seatsInfo || [];\n\n    for (var _i2 = 0; _i2 < seatsInfo.length; _i2++) {\n      var seatInfo = seatsInfo[_i2];\n\n      if (!placesIndex[seatInfo.id]) {\n        continue;\n      }\n\n      var placeObject = placesIndex[seatInfo.id];\n      placeObject.setSeatInfo(seatInfo);\n      placeObject.setSectionId(sectionDetails.id);\n      var seatPriceClass = priceClassesIndex[seatInfo.priceClass] || null;\n      var selectable = seatsManuallySelectable && seatInfo;\n      placeObject.setPriceClass(seatPriceClass);\n      placeObject.setSelected(venueMap.isSeatSelected(seatInfo.id));\n      placeObject.allowManuallySelectable(selectable);\n      placeObject.allowSeatsStatusDisplaying(venueMap.isSeatsStatusDisplayed());\n      placeObject.refreshStatus();\n    }\n  };\n\n  this.setTextContent = function (element, text) {\n    text = text || '';\n\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n\n    element.appendChild(document.createTextNode(text));\n  };\n\n  this.setSectionsBoundaries = function (newSectionsBoundaries) {\n    sectionsBoundaries = newSectionsBoundaries;\n  };\n\n  this.resize = function () {\n    componentElement.style.width = '';\n    componentElement.style.height = '';\n    containerElement.style.width = '';\n    containerElement.style.height = '';\n    var paddings = getPaddings();\n    var svgStyle = svgElement.style;\n\n    if (venueMap.getFixedHeight()) {\n      containerElement.style.height = venueMap.getFixedHeight() - container.getLegendHeight() + 'px';\n    } else {\n      var svgWidth, svgHeight;\n      svgWidth = componentElement.offsetWidth - paddings.left - paddings.right;\n      svgHeight = svgWidth / aspectRatio;\n      svgStyle.width = svgWidth + 'px';\n      svgStyle.height = svgHeight + 'px';\n      var highSvg = componentElement.offsetHeight > containerElement.offsetHeight;\n\n      if (highSvg) {\n        // container has limited height\n        svgHeight = containerElement.offsetHeight - paddings.top - paddings.bottom;\n        svgWidth = svgHeight * aspectRatio;\n      }\n\n      svgStyle.width = svgWidth + 'px';\n      svgStyle.height = svgHeight + 'px';\n    }\n\n    containerDimensions = {\n      width: containerElement.offsetWidth,\n      height: containerElement.offsetHeight\n    };\n    containerInnerDimensions = {\n      width: containerDimensions.width - paddings.left - paddings.right,\n      height: containerDimensions.height - paddings.top - paddings.bottom\n    };\n    componentElement.style.width = containerDimensions.width + 'px';\n    componentElement.style.height = containerDimensions.height + 'px';\n    containerElement.style.width = containerDimensions.width + 'px';\n    containerElement.style.height = containerDimensions.height + 'px';\n    svgStyle.width = '';\n    svgStyle.height = '';\n    lastZoomlevel = -1;\n    var focalPoint = getCurrentRelativeFocalPoint();\n    focalPoint.centered = true;\n    calculateMaxZoomLevel();\n    self.registerScalableElement({\n      'scaledElement': componentElement,\n      'gestureElement': componentElement,\n      'minWidth': containerElement.offsetWidth,\n      'minHeight': containerElement.offsetWidth / aspectRatio,\n      'maxWidth': maxZoomWidth,\n      'afterStartCallback': scaleStartCallback,\n      'preChangeCallback': scaleChangeCallback,\n      'endCallback': scaleEndCallback\n    });\n\n    if (venueMap.getZoomLevel() > maxZoomLevel) {\n      venueMap.setZoomLevel(maxZoomLevel, false);\n    } else {\n      self.adjustToZoom(false, focalPoint);\n      container.adjustZoomControls();\n    }\n  };\n\n  var getPaddings = function getPaddings() {\n    var style = window.getComputedStyle(componentElement);\n    return {\n      top: parseFloat(style.paddingTop),\n      bottom: parseFloat(style.paddingBottom),\n      left: parseFloat(style.paddingLeft),\n      right: parseFloat(style.paddingRight)\n    };\n  };\n\n  this.adjustToZoom = function (withAnimation, newFocalPoint) {\n    withAnimation = withAnimation || typeof withAnimation == 'undefined';\n    var zoomLevel = venueMap.getZoomLevel();\n\n    if (zoomLevel === lastZoomlevel) {\n      return;\n    }\n\n    var zoomDiff = Math.abs(lastZoomlevel - zoomLevel);\n\n    if (zoomDiff > 1) {\n      // for smoother resizing\n      adjustNumberingVisibility(false);\n    }\n\n    lastZoomlevel = zoomLevel;\n    adjustSectionLabelsVisibility(false);\n    var mapWidth = applyZoom(containerDimensions.width, zoomLevel);\n    var mapHeight = applyZoom(containerDimensions.height, zoomLevel);\n    var top = 0,\n        left = 0;\n\n    if (zoomLevel > 0) {\n      var focalPoint = newFocalPoint;\n\n      if (!focalPoint) {\n        focalPoint = getCurrentRelativeFocalPoint();\n      }\n\n      var scaledPosition = getScaledMapPosition(mapWidth, mapHeight, focalPoint);\n      top = scaledPosition.y;\n      left = scaledPosition.x;\n    }\n\n    if (withAnimation) {\n      var animDuration = Math.min(zoomDiff * 150, 800);\n      Piletilevi.venuemap.Utilities.animate(componentElement, {\n        top: top + 'px',\n        left: left + 'px',\n        width: mapWidth + 'px',\n        height: mapHeight + 'px'\n      }, animDuration, 'ease-in-out', zoomAdjusted);\n    } else {\n      componentElement.style.top = top + 'px';\n      componentElement.style.left = left + 'px';\n      componentElement.style.width = mapWidth + 'px';\n      componentElement.style.height = mapHeight + 'px';\n      zoomAdjusted();\n    }\n  };\n\n  var getScaledMapPosition = function getScaledMapPosition(newWidth, newHeight, focalPoint) {\n    var top, left;\n\n    if (focalPoint.centered) {\n      var concreteFocalPoint = {\n        x: newWidth * focalPoint.x,\n        y: newHeight * focalPoint.y\n      };\n      var centerY = containerDimensions.height / 2;\n      top = centerY - concreteFocalPoint.y;\n      var centerX = containerDimensions.width / 2;\n      left = centerX - concreteFocalPoint.x;\n    } else {\n      var originalX = componentElement.offsetWidth * focalPoint.x;\n      var newX = newWidth * focalPoint.x;\n      var originalY = componentElement.offsetHeight * focalPoint.y;\n      var newY = newHeight * focalPoint.y;\n      top = componentElement.offsetTop - (newY - originalY);\n      left = componentElement.offsetLeft - (newX - originalX);\n    }\n\n    top = Math.min(top, 0);\n    top = Math.max(top, containerDimensions.height - newHeight);\n    top = Math.round(top);\n    left = Math.min(left, 0);\n    left = Math.max(left, containerDimensions.width - newWidth);\n    left = Math.round(left);\n    return {\n      x: left,\n      y: top\n    };\n  };\n\n  var getCurrentRelativeFocalPoint = function getCurrentRelativeFocalPoint() {\n    return self.getPointRelativeToContainer(containerDimensions.width / 2, containerDimensions.height / 2);\n  };\n\n  var zoomAdjusted = function zoomAdjusted() {\n    adjustDetailsDisplaying();\n\n    if (lastZoomlevel > 0) {\n      self.enableDragging();\n    } else {\n      self.disableDragging();\n    }\n  };\n\n  this.setDisplayed = function (newDisplayed) {\n    if (displayed !== newDisplayed) {\n      displayed = newDisplayed;\n      componentElement.style.display = displayed ? '' : 'none';\n\n      if (displayed) {\n        self.resize();\n      }\n    }\n  };\n\n  this.getPointRelativeToContainer = function (x, y) {\n    return {\n      x: (x - componentElement.offsetLeft) / componentElement.offsetWidth,\n      y: (y - componentElement.offsetTop) / componentElement.offsetHeight\n    };\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  this.getContainerElement = function () {\n    return containerElement;\n  };\n\n  this.selectSection = function (sectionId) {\n    if (!sectionId) {\n      venueMap.setZoomLevel(0);\n      return;\n    }\n\n    var boundary = sectionsBoundaries[sectionId] || null;\n\n    if (!boundary) {\n      return;\n    }\n\n    var maxZoomLevel = 32;\n    var endWidth;\n    var endHeight;\n    var endZoom = 0;\n    var endDimensions;\n    var endSvgDimensions;\n\n    for (var testZoom = 0; testZoom <= maxZoomLevel; ++testZoom) {\n      var zoomDimensions = {\n        width: applyZoom(containerInnerDimensions.width, testZoom),\n        height: applyZoom(containerInnerDimensions.height, testZoom)\n      };\n      var zoomSvgDimensions = getNaturalSvgDimensions({\n        width: zoomDimensions.width,\n        height: zoomDimensions.height\n      });\n      var svgZoomRatio = zoomSvgDimensions.width / svgDimensions.width;\n      endWidth = svgZoomRatio * boundary.width;\n      endHeight = svgZoomRatio * boundary.height;\n\n      if (endWidth > containerInnerDimensions.width || endHeight > containerInnerDimensions.height) {\n        break;\n      }\n\n      endZoom = testZoom;\n      endDimensions = zoomDimensions;\n      endSvgDimensions = zoomSvgDimensions;\n      var seatRadius = getSeatRadiusByMapWidth(zoomSvgDimensions.width);\n\n      if (seatRadius > sectionZoomSeatRadius) {\n        break;\n      }\n    }\n\n    var nextFocalPoint = null;\n\n    if (endZoom > 0) {\n      var boundarySvgPoint = {\n        x: (boundary.x + boundary.width / 2) / svgDimensions.width,\n        y: (boundary.y + boundary.height / 2) / svgDimensions.height\n      };\n      nextFocalPoint = {\n        x: (endSvgDimensions.width * boundarySvgPoint.x + (endDimensions.width - endSvgDimensions.width) / 2) / endDimensions.width,\n        y: (endSvgDimensions.height * boundarySvgPoint.y + (endDimensions.height - endSvgDimensions.height) / 2) / endDimensions.height,\n        centered: true\n      };\n    }\n\n    venueMap.setZoomLevel(endZoom, true, nextFocalPoint);\n  };\n\n  this.getSelectedSeats = function () {\n    var result = [];\n\n    for (var key in placesIndex) {\n      if (placesIndex[key].isSelected()) {\n        result.push(placesIndex[key]);\n      }\n    }\n\n    return result;\n  };\n\n  this.selectSeatsInRegion = function (region, exclusions) {\n    exclusions = exclusions || {};\n    var svgRect = svgElement.getBoundingClientRect();\n    var componentRect = componentElement.getBoundingClientRect();\n    var svgOffsetTop = svgRect.top - componentRect.top;\n    var svgOffsetLeft = svgRect.left - componentRect.left;\n    var regionTop = region.top - componentElement.offsetTop;\n    var regionLeft = region.left - componentElement.offsetLeft;\n    var naturalDimensions = getNaturalSvgDimensions(svgRect);\n    var mapSizeDiff = naturalDimensions.width / svgDimensions.width; // since SVG has been stretched to fill whole container, but its aspect ratio preserved,\n    // its contents have shifted from the element's position in DOM\n\n    var svgContentsOffsetTop = (svgRect.height - naturalDimensions.height) / 2;\n    var svgContentsOffsetLeft = (svgRect.width - naturalDimensions.width) / 2;\n    svgContentsOffsetTop += svgOffsetTop;\n    svgContentsOffsetLeft += svgOffsetLeft;\n\n    for (var key in placesIndex) {\n      var place = placesIndex[key];\n      var info = place.getSeatInfo();\n\n      if (!place.canBeSelected() || exclusions[info.id]) {\n        continue;\n      }\n\n      var element = place.getElement();\n      var x = element.getAttribute('cx') * mapSizeDiff + svgContentsOffsetLeft;\n      var y = element.getAttribute('cy') * mapSizeDiff + svgContentsOffsetTop;\n      var outside = x < regionLeft || x > regionLeft + region.width || y < regionTop || y > regionTop + region.height;\n\n      if (place.isSelected() === !outside) {\n        continue;\n      }\n\n      place.setSelected(!outside);\n      place.refreshStatus();\n    }\n  };\n\n  this.dragSeats = function (sectionId, nearSeat) {\n    var dragger = new Piletilevi.venuemap.DragTicketsPositioner();\n    var details = sectionsDetails[sectionId];\n    var seats = dragger.findNewSeats(nearSeat, selectedSeats, details);\n    seats.map(function (seat) {\n      placesIndex[seat.id].highlight();\n    });\n  };\n\n  var adjustDetailsDisplaying = function adjustDetailsDisplaying() {\n    var currentSvgDimensions = getNaturalSvgDimensions();\n    var currentSeatRadius = getSeatRadiusByMapWidth(currentSvgDimensions.width);\n    var showSeats = currentSeatRadius >= seatNumbersRequirement;\n    adjustNumberingVisibility(showSeats);\n    var showSections = venueMap.getSectionsMapType() === 'full_venue' && !showSeats && currentSeatRadius >= sectionLabelsRequirement;\n\n    if (showSections) {\n      var ratio = currentSvgDimensions.width / svgDimensions.width;\n      var labelSize = sectionLabelSize / ratio;\n\n      for (var key in sectionLabelElements) {\n        if (sectionLabelElements.hasOwnProperty(key)) {\n          sectionLabelElements[key].setAttribute('font-size', labelSize);\n        }\n      }\n    }\n\n    adjustSectionLabelsVisibility(showSections);\n  };\n\n  var getNaturalSvgDimensions = function getNaturalSvgDimensions(dimensions) {\n    // SVG has been stretched to fill whole container, this returns\n    // dimensions as if only height or width had been stretched\n    dimensions = dimensions || svgElement.getBoundingClientRect();\n    var result = {\n      width: dimensions.width,\n      height: dimensions.height\n    };\n    var dimensionsByRatio = {\n      width: result.height * aspectRatio,\n      height: result.width / aspectRatio\n    };\n    var heightReliable = result.width / dimensionsByRatio.width > result.height / dimensionsByRatio.height;\n\n    if (heightReliable) {\n      result.width = dimensionsByRatio.width;\n    } else {\n      result.height = dimensionsByRatio.height;\n    }\n\n    return result;\n  };\n\n  var getSeatRadiusByMapWidth = function getSeatRadiusByMapWidth(width) {\n    var diff = width / svgDimensions.width;\n    return Math.round(Piletilevi.venuemap.SEAT_CIRCLE_RADIUS * diff);\n  };\n\n  var adjustNumberingVisibility = function adjustNumberingVisibility(visible) {\n    if (visible) {\n      Piletilevi.venuemap.Utilities.addClass(svgElement, 'with_seat_numbers');\n    } else {\n      Piletilevi.venuemap.Utilities.removeClass(svgElement, 'with_seat_numbers');\n    }\n  };\n\n  var adjustSectionLabelsVisibility = function adjustSectionLabelsVisibility(visible) {\n    if (visible) {\n      Piletilevi.venuemap.Utilities.addClass(svgElement, 'with_section_labels');\n    } else {\n      Piletilevi.venuemap.Utilities.removeClass(svgElement, 'with_section_labels');\n    }\n  };\n\n  var applyZoom = function applyZoom(value, zoomLevel) {\n    return value * Math.pow(zoomFactor, zoomLevel);\n  };\n\n  init();\n};\n\n__ScalableComponent.call(Piletilevi.venuemap.PlacesMapCanvas.prototype);\n\n__DraggableComponent.call(Piletilevi.venuemap.PlacesMapCanvas.prototype);\n\nPiletilevi.venuemap.PlacesMapPlace = function (venueMap, placeElement) {\n  var self = this;\n  var STATUS_TAKEN = 0;\n  var STATUS_AVAILABLE = 1;\n  var STATUS_SELECTED = 2;\n  this.id = false;\n  var seatInfo;\n  var sectionId;\n  var manuallySelectable = false;\n  var seatsStatusDisplayed = false;\n  var inactiveNumbered = false;\n  var withText = true;\n  var priceClass;\n  var status = STATUS_TAKEN;\n  var textElement;\n\n  var init = function init() {\n    textElement = placeElement.querySelector('text');\n    inactiveNumbered = venueMap.areInactiveSeatsNumbered();\n    self.refreshStatus();\n  };\n\n  var mouseMove = function mouseMove(event) {\n    var x = Math.max(0, event.pageX);\n    var y = Math.max(0, event.pageY - 2);\n    venueMap.getPlaceToolTip().display(seatInfo, status, x, y);\n    self.highlight();\n  };\n\n  var mouseOut = function mouseOut() {\n    venueMap.getPlaceToolTip().hide();\n\n    if (manuallySelectable) {\n      self.refreshStatus();\n    }\n  };\n\n  var pointerEnd = function pointerEnd(event) {\n    event.preventDefault();\n\n    if (manuallySelectable && seatInfo) {\n      if (status === STATUS_AVAILABLE) {\n        status = STATUS_SELECTED;\n        self.refreshStatus();\n        venueMap.trigger('seatsSelected', [seatInfo.id]);\n        venueMap.trigger('seatSelected', seatInfo.id);\n      } else if (status === STATUS_SELECTED) {\n        status = STATUS_AVAILABLE;\n        self.refreshStatus();\n        venueMap.trigger('seatsDeselected', [seatInfo.id]);\n        venueMap.trigger('seatUnSelected', seatInfo.id);\n      }\n    }\n  };\n\n  var pointerStart = function pointerStart(event) {\n    event.preventDefault();\n\n    if (seatInfo) {\n      venueMap.dragSeats(sectionId, seatInfo);\n    }\n  };\n\n  this.refreshStatus = function () {\n    var seatColor;\n    withText = true;\n\n    if (status === STATUS_SELECTED) {\n      seatColor = venueMap.getSeatColor('active');\n    } else if (priceClass && (status === STATUS_AVAILABLE || !seatsStatusDisplayed)) {\n      seatColor = priceClass.color;\n    } else {\n      seatColor = venueMap.getSeatColor('inactive');\n      withText = inactiveNumbered;\n    }\n\n    if (textElement) {\n      textElement.style.display = withText ? '' : 'none';\n    }\n\n    setColor(seatColor);\n\n    if (seatInfo) {\n      if (venueMap.isSeatDraggingEnabled()) {\n        touchManager.addEventListener(placeElement, 'start', pointerStart);\n      }\n\n      placeElement.addEventListener('mousemove', mouseMove);\n      placeElement.addEventListener('mouseout', mouseOut);\n    } else {\n      if (venueMap.isSeatDraggingEnabled()) {\n        touchManager.removeEventListener(placeElement, 'start', pointerStart);\n      }\n\n      placeElement.removeEventListener('mousemove', mouseMove);\n      placeElement.removeEventListener('mouseout', mouseOut);\n    }\n\n    if (seatInfo && manuallySelectable && (status === STATUS_AVAILABLE || status === STATUS_SELECTED)) {\n      touchManager.addEventListener(placeElement, 'end', pointerEnd);\n    } else {\n      touchManager.removeEventListener(placeElement, 'end', pointerEnd);\n    }\n  };\n\n  var setColor = function setColor(seatColor) {\n    if (placeElement) {\n      if (manuallySelectable) {\n        placeElement.setAttribute('style', 'cursor:pointer;fill:' + seatColor);\n      } else {\n        placeElement.setAttribute('style', 'fill:' + seatColor);\n      }\n\n      if (textElement && withText) {\n        if (seatColor === venueMap.getSeatColor('inactive')) {\n          textElement.setAttribute('fill', '#000000');\n        } else {\n          textElement.setAttribute('fill', '#ffffff');\n        }\n      }\n    }\n  };\n\n  this.canBeSelected = function () {\n    return manuallySelectable && seatInfo && (status === STATUS_AVAILABLE || status === STATUS_SELECTED);\n  };\n\n  this.allowManuallySelectable = function (newSelectable) {\n    manuallySelectable = !!newSelectable;\n  };\n\n  this.allowSeatsStatusDisplaying = function (newSelectable) {\n    seatsStatusDisplayed = !!newSelectable;\n  };\n\n  this.isSelectable = function () {\n    return manuallySelectable;\n  };\n\n  this.getSeatInfo = function () {\n    return seatInfo;\n  };\n\n  this.setSeatInfo = function (newSeatInfo) {\n    seatInfo = newSeatInfo;\n\n    if (typeof seatInfo['status'] !== 'undefined') {\n      status = seatInfo['status'];\n    }\n  };\n\n  this.setSectionId = function (newSectionId) {\n    sectionId = newSectionId;\n  };\n\n  this.setPriceClass = function (newPriceClass) {\n    priceClass = newPriceClass;\n  };\n\n  this.setSelected = function (newSelected) {\n    switch (status) {\n      case STATUS_AVAILABLE:\n      case STATUS_SELECTED:\n        status = newSelected ? STATUS_SELECTED : STATUS_AVAILABLE;\n        break;\n    }\n  };\n\n  this.isSelected = function () {\n    return status === STATUS_SELECTED;\n  };\n\n  this.getElement = function () {\n    return placeElement;\n  };\n\n  this.highlight = function () {\n    if (manuallySelectable) {\n      setColor(venueMap.getSeatColor('hover'));\n    }\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.PlaceMapLegendItem = function (text, color, extraClass, suffix) {\n  this.colorElement = false;\n  this.titleElement = false;\n  this.suffixElement = false;\n  this.text = false;\n  this.color = false;\n  var componentElement;\n\n  this.init = function () {\n    this.text = text;\n    this.color = color;\n    componentElement = document.createElement('span');\n    componentElement.className = 'places_map_legend_item';\n\n    if (extraClass) {\n      componentElement.className += ' places_map_legend_item_' + extraClass;\n    }\n\n    this.colorElement = document.createElement('span');\n    this.colorElement.className = 'places_map_legend_color';\n    componentElement.appendChild(this.colorElement);\n    this.titleElement = document.createElement('span');\n    this.titleElement.className = 'places_map_legend_title';\n    componentElement.appendChild(this.titleElement);\n\n    if (suffix) {\n      this.suffixElement = document.createElement('span');\n      this.suffixElement.className = 'places_map_legend_suffix';\n      componentElement.appendChild(this.suffixElement);\n    }\n\n    this.refreshContents();\n  };\n\n  this.refreshContents = function () {\n    var titleText = this.text;\n    this.setTextContent(this.titleElement, titleText);\n\n    if (suffix) {\n      this.setTextContent(this.suffixElement, suffix);\n    }\n\n    this.colorElement.style.backgroundColor = this.color;\n  };\n\n  this.setTextContent = function (element, text) {\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n\n    var textNode = document.createTextNode(text);\n    element.appendChild(textNode);\n  };\n\n  this.getComponentElement = function () {\n    return componentElement;\n  };\n\n  this.init();\n};\n\nPiletilevi.venuemap.PlacesMapStageLabel = function (venueMap, textElement) {\n  var self = this;\n\n  var init = function init() {\n    var type = self.getText();\n\n    if (type) {\n      self.setText(venueMap.getTranslation('stage-' + type));\n    }\n\n    if (venueMap.isPlacesMapFlipped()) {\n      var x = textElement.getAttribute('x');\n      var y = textElement.getAttribute('y');\n      textElement.setAttribute('transform', 'rotate(180 ' + x + ' ' + y + ')');\n    }\n  };\n\n  this.setText = function (newText) {\n    if (textElement.String) {\n      textElement.String = newText;\n    } else {\n      while (textElement.firstChild) {\n        textElement.removeChild(textElement.firstChild);\n      }\n\n      var node = document.createTextNode(newText);\n      textElement.appendChild(node);\n    }\n  };\n\n  this.getText = function () {\n    return textElement.textContent || textElement.String;\n  };\n\n  init();\n};\n\nPiletilevi.venuemap.PlaceTooltip = function (venueMap) {\n  var self = this;\n  var componentElement;\n  var sectionElement;\n  var sectionTitleElement;\n  var rowRowElement;\n  var rowElement;\n  var placeRowElement;\n  var placeElement;\n  var priceElement;\n  var statusElement;\n  var priceRowElement;\n  var statusRowElement;\n  var popupOffset = 0;\n\n  var createDomElements = function createDomElements() {\n    componentElement = document.createElement('div');\n    componentElement.className = 'place_tooltip';\n    componentElement.style.display = 'none';\n    document.body.appendChild(componentElement);\n    var contentElement = document.createElement('div');\n    contentElement.className = 'place_tooltip_content';\n    componentElement.appendChild(contentElement);\n    var tableElement = document.createElement('table');\n    contentElement.appendChild(tableElement);\n    var tBodyElement = document.createElement('tbody');\n    tableElement.appendChild(tBodyElement);\n    var labelElement;\n    sectionElement = document.createElement('tr');\n    tBodyElement.appendChild(sectionElement);\n    labelElement = document.createElement('td');\n    labelElement.className = 'place_tooltip_label';\n    labelElement.appendChild(document.createTextNode(venueMap.getTranslation('section')));\n    sectionElement.appendChild(labelElement);\n    sectionTitleElement = document.createElement('td');\n    sectionTitleElement.className = 'place_tooltip_value';\n    sectionElement.appendChild(sectionTitleElement);\n    rowRowElement = document.createElement('tr');\n    tBodyElement.appendChild(rowRowElement);\n    labelElement = document.createElement('td');\n    labelElement.className = 'place_tooltip_label';\n    labelElement.appendChild(document.createTextNode(venueMap.getTranslation('row')));\n    rowRowElement.appendChild(labelElement);\n    rowElement = document.createElement('td');\n    rowElement.className = 'place_tooltip_value';\n    rowRowElement.appendChild(rowElement);\n    placeRowElement = document.createElement('tr');\n    tBodyElement.appendChild(placeRowElement);\n    labelElement = document.createElement('td');\n    labelElement.className = 'place_tooltip_label';\n    labelElement.appendChild(document.createTextNode(venueMap.getTranslation('place')));\n    placeRowElement.appendChild(labelElement);\n    placeElement = document.createElement('td');\n    placeElement.className = 'place_tooltip_value';\n    placeRowElement.appendChild(placeElement);\n    priceRowElement = document.createElement('tr');\n    tBodyElement.appendChild(priceRowElement);\n    labelElement = document.createElement('td');\n    labelElement.className = 'place_tooltip_label';\n    labelElement.appendChild(document.createTextNode(venueMap.getTranslation('price')));\n    priceRowElement.appendChild(labelElement);\n    priceElement = document.createElement('td');\n    priceElement.className = 'place_tooltip_value';\n    priceRowElement.appendChild(priceElement);\n    statusRowElement = document.createElement('tr');\n    tBodyElement.appendChild(statusRowElement);\n    statusElement = document.createElement('td');\n    statusElement.setAttribute('colspan', '2');\n    statusElement.className = 'place_tooltip_status';\n    statusRowElement.appendChild(statusElement);\n  };\n\n  this.clear = function () {\n    while (rowElement.firstChild) {\n      rowElement.removeChild(rowElement.firstChild);\n    }\n\n    while (placeElement.firstChild) {\n      placeElement.removeChild(placeElement.firstChild);\n    }\n\n    while (priceElement.firstChild) {\n      priceElement.removeChild(priceElement.firstChild);\n    }\n\n    while (statusElement.firstChild) {\n      statusElement.removeChild(statusElement.firstChild);\n    }\n\n    while (sectionTitleElement.firstChild) {\n      sectionTitleElement.removeChild(sectionTitleElement.firstChild);\n    }\n\n    rowRowElement.style.display = 'none';\n    placeRowElement.style.display = 'none';\n    priceRowElement.style.display = 'none';\n    statusRowElement.style.display = 'none';\n    sectionElement.style.display = 'none';\n  };\n\n  this.display = function (seat, status, x, y) {\n    if (!componentElement) {\n      createDomElements();\n    }\n\n    self.clear();\n    var statuses = {\n      0: 'booked',\n      1: 'available',\n      2: 'selected',\n      3: 'not_sold'\n    };\n    var statusCode = statuses[status] || statuses[0];\n    var sectionTitle = '';\n\n    if (venueMap.getSectionsMapType() === 'full_venue') {\n      var section = venueMap.getSectionBySeatId(seat.id);\n      sectionTitle = section ? section.title : '';\n    }\n\n    if (sectionTitle) {\n      sectionTitleElement.appendChild(document.createTextNode(sectionTitle));\n      sectionElement.style.display = '';\n    }\n\n    if (statusCode !== 'not_sold') {\n      if (seat.row) {\n        rowElement.appendChild(document.createTextNode(seat.row));\n        rowRowElement.style.display = '';\n      }\n\n      if (seat.place) {\n        placeElement.appendChild(document.createTextNode(seat.place));\n        placeRowElement.style.display = '';\n      }\n    }\n\n    if (venueMap.isSeatSelectionEnabled()) {\n      var text = venueMap.getTranslation(statusCode);\n      statusElement.appendChild(document.createTextNode(text));\n      statusRowElement.style.display = '';\n    }\n\n    if (seat.price && statusCode !== 'booked' && statusCode !== 'not_sold') {\n      priceElement.appendChild(document.createTextNode(seat.price));\n      priceRowElement.style.display = '';\n    }\n\n    var viewPortWidth;\n\n    if (window.innerHeight) {\n      viewPortWidth = window.innerWidth;\n    } else {\n      viewPortWidth = document.documentElement.offsetWidth;\n    }\n\n    componentElement.style.left = 0 + 'px';\n    componentElement.style.top = 0 + 'px';\n    componentElement.style.visibility = 'hidden';\n    componentElement.style.display = 'block';\n    var popupWidth = componentElement.offsetWidth;\n    var popupHeight = componentElement.offsetHeight;\n    var leftPosition = x + popupOffset;\n    leftPosition -= popupWidth / 2;\n    var topPosition = y - popupHeight - popupOffset;\n\n    if (leftPosition + popupWidth + popupOffset >= viewPortWidth) {\n      leftPosition = x - popupOffset - popupWidth;\n    }\n\n    if (topPosition - popupOffset < 0) {\n      topPosition = y + popupOffset + popupHeight;\n    }\n\n    componentElement.style.left = leftPosition + 'px';\n    componentElement.style.top = topPosition + 'px';\n    componentElement.style.visibility = 'visible';\n  };\n\n  this.hide = function () {\n    if (componentElement) {\n      componentElement.style.display = 'none';\n    }\n  };\n\n  this.dispose = function () {\n    window.removeEventListener('resize', self.resize);\n\n    if (componentElement && componentElement.parentNode) {\n      componentElement.parentNode.removeChild(componentElement);\n    }\n\n    componentElement = null;\n  };\n};\n\nPiletilevi.venuemap.VenuePlacesMapCanvasFactory = function (venueMap) {\n  this.createCanvas = function (options) {\n    var data = JSON.parse(JSON.stringify(options.data));\n    var relevantSections = options.relevantSections || [];\n    var svgElement = Piletilevi.venuemap.Utilities.createSvgNode('svg', {\n      viewBox: '0 0 ' + data.width + ' ' + data.height,\n      width: '100%',\n      height: '100%'\n    });\n    var node;\n    var sectionsSeats = {};\n    var rowEdges = {};\n\n    var rowEdgeStruct = function rowEdgeStruct() {\n      this.firstSeat = null;\n      this.lastSeat = null;\n    };\n\n    var relevantSeats = [];\n    var relevantSectionsIndex = {};\n\n    for (var i = relevantSections.length; i--;) {\n      relevantSectionsIndex[relevantSections[i]] = true;\n    }\n\n    for (var _i3 = 0; _i3 < data.seats.length; ++_i3) {\n      var seat = data.seats[_i3];\n      var section = seat.section;\n\n      if (!relevantSectionsIndex[section]) {\n        continue;\n      }\n\n      if (!sectionsSeats[section]) {\n        sectionsSeats[section] = [];\n      }\n\n      var rowKey = section + '_' + seat.row;\n\n      if (!rowEdges[rowKey]) {\n        rowEdges[rowKey] = new rowEdgeStruct();\n      }\n\n      var rowEdge = rowEdges[rowKey];\n\n      if (!rowEdge.firstSeat || +rowEdge.firstSeat.place > +seat.place) {\n        rowEdge.firstSeat = seat;\n      }\n\n      if (!rowEdge.lastSeat || +rowEdge.lastSeat.place < +seat.place) {\n        rowEdge.lastSeat = seat;\n      }\n\n      sectionsSeats[section].push(seat);\n      relevantSeats.push(seat);\n    } // trim the map\n\n\n    var mapRegion = calculateSeatsRegion(relevantSeats);\n    var paddingX = 0;\n    var paddingY = 0;\n    var maxAspectRatio = 2.25;\n    var minAspectRatio = 0.75;\n\n    if (mapRegion.width / mapRegion.height > maxAspectRatio) {\n      // too short\n      var newHeight = mapRegion.width / maxAspectRatio;\n      paddingY = (newHeight - mapRegion.height) / 2;\n    } else if (mapRegion.width / mapRegion.height < minAspectRatio) {\n      // too slim\n      var newWidth = mapRegion.height * minAspectRatio;\n      paddingX = (newWidth - mapRegion.width) / 2;\n    }\n\n    var paddingForRowLabels = Piletilevi.venuemap.SEAT_CIRCLE_RADIUS * 4.5;\n\n    if (paddingForRowLabels > paddingX || paddingForRowLabels > paddingY) {\n      paddingX += paddingForRowLabels;\n      paddingY += paddingForRowLabels;\n    }\n\n    mapRegion.x -= paddingX;\n    mapRegion.y -= paddingY;\n    mapRegion.width += paddingX * 2;\n    mapRegion.height += paddingY * 2;\n\n    if (options.withStage && data.stageType) {\n      var textSize = Piletilevi.venuemap.Utilities.getSvgTextBBox(venueMap.getTranslation('stage-' + data.stageType), {\n        'font-size': Piletilevi.venuemap.STAGE_TEXT_SIZE,\n        'font-weight': 'bold'\n      });\n      var textX = data.stageX - textSize.width / 2;\n      var textY = data.stageY - textSize.height / 2;\n\n      if (textX < mapRegion.x) {\n        mapRegion.width += mapRegion.x - textX;\n        mapRegion.x = textX;\n      }\n\n      if (textY < mapRegion.y) {\n        mapRegion.height += mapRegion.y - textY;\n        mapRegion.y = textY;\n      }\n\n      if (mapRegion.width < textX + textSize.width) {\n        mapRegion.width = textX + textSize.width;\n      }\n\n      if (mapRegion.height < textY + textSize.height) {\n        mapRegion.height = textY + textSize.height;\n      }\n    }\n\n    svgElement.setAttribute('viewBox', '0 0 ' + mapRegion.width + ' ' + mapRegion.height);\n    data.stageX -= mapRegion.x;\n    data.stageY -= mapRegion.y;\n\n    for (var _i4 = relevantSeats.length; _i4--;) {\n      var _seat = relevantSeats[_i4];\n      _seat.x -= mapRegion.x;\n      _seat.y -= mapRegion.y;\n    }\n\n    if (options.withStage && data.stageType) {\n      node = Piletilevi.venuemap.Utilities.createSvgNode('text', {\n        id: 'stagename',\n        'text-anchor': 'middle',\n        x: data.stageX,\n        y: data.stageY,\n        fill: '#999999',\n        'font-size': Piletilevi.venuemap.STAGE_TEXT_SIZE,\n        'font-weight': 'bold',\n        'dy': '0.3em'\n      });\n      var textNode = document.createTextNode(data.stageType);\n      node.appendChild(textNode);\n      svgElement.appendChild(node);\n    }\n\n    for (var key in rowEdges) {\n      var edge = rowEdges[key];\n\n      if (!edge.firstSeat || !edge.lastSeat) {\n        continue;\n      }\n\n      svgElement.appendChild(createRowNumberNode(edge.firstSeat, edge.lastSeat));\n      svgElement.appendChild(createRowNumberNode(edge.lastSeat, edge.firstSeat));\n    }\n\n    for (var _i5 = 0; _i5 < relevantSeats.length; ++_i5) {\n      var _seat2 = relevantSeats[_i5];\n      var groupNode = Piletilevi.venuemap.Utilities.createSvgNode('g', {\n        'class': 'place',\n        id: 'place_' + _seat2.code,\n        cx: _seat2.x,\n        cy: _seat2.y\n      });\n      svgElement.appendChild(groupNode);\n\n      var _node = Piletilevi.venuemap.Utilities.createSvgNode('circle', {\n        cx: _seat2.x,\n        cy: _seat2.y,\n        r: Piletilevi.venuemap.SEAT_CIRCLE_RADIUS\n      });\n\n      groupNode.appendChild(_node);\n\n      if (_seat2.place) {\n        var attributes = {\n          'class': 'place_detail seat_text',\n          x: _seat2.x,\n          y: _seat2.y,\n          dy: '0.35em',\n          // center align vertically\n          'stroke-width': 0,\n          'text-anchor': 'middle',\n          // center align horizontally\n          'font-size': 6.9\n        };\n\n        if (venueMap.isPlacesMapFlipped()) {\n          attributes['transform'] = 'rotate(180 ' + _seat2.x + ' ' + _seat2.y + ')';\n        }\n\n        _node = Piletilevi.venuemap.Utilities.createSvgNode('text', attributes);\n\n        var _textNode = document.createTextNode(_seat2.place);\n\n        _node.appendChild(_textNode);\n\n        groupNode.appendChild(_node);\n      }\n    }\n\n    var boundaries = {};\n    var sectionLabelElements = {};\n\n    for (var sectionId in sectionsSeats) {\n      var sectionRegion = calculateSeatsRegion(sectionsSeats[sectionId]);\n\n      if (Piletilevi.venuemap.DEBUG_FULL_PLACESMAP_SECTIONS) {\n        var _node3 = Piletilevi.venuemap.Utilities.createSvgNode('rect', {\n          x: sectionRegion.x,\n          y: sectionRegion.y,\n          width: sectionRegion.width,\n          height: sectionRegion.height,\n          fill: '#7f52ff',\n          'data-section': sectionId\n        });\n\n        svgElement.appendChild(_node3);\n      }\n\n      var _node2 = Piletilevi.venuemap.Utilities.createSvgNode('text', {\n        'class': 'section_label',\n        x: sectionRegion.x + sectionRegion.width / 2,\n        y: sectionRegion.y + sectionRegion.height / 2,\n        dy: '-0.35em',\n        // center align vertically\n        'text-anchor': 'middle',\n        // center align horizontally\n        'font-size': 14,\n        'fill': '#000000'\n      });\n\n      sectionLabelElements[sectionId] = _node2;\n      svgElement.appendChild(_node2);\n      boundaries[sectionId] = sectionRegion;\n    }\n\n    venueMap.displayMapInPlaces = data.displayMapInPlaces === 1;\n    var canvas = new Piletilevi.venuemap.PlacesMapCanvas(venueMap, svgElement, sectionLabelElements);\n    canvas.setSectionsBoundaries(boundaries);\n    return canvas;\n  };\n\n  var calculateSeatsRegion = function calculateSeatsRegion(seats) {\n    var topLeft = {\n      x: -1,\n      y: -1\n    };\n    var bottomRight = {\n      x: -1,\n      y: -1\n    };\n\n    for (var i = 0; i < seats.length; ++i) {\n      var seat = seats[i];\n      var x = +seat.x;\n      var y = +seat.y;\n\n      if (topLeft.x < 0 || x < topLeft.x) {\n        topLeft.x = x;\n      }\n\n      if (topLeft.y < 0 || y < topLeft.y) {\n        topLeft.y = y;\n      }\n\n      if (bottomRight.x < 0 || x > bottomRight.x) {\n        bottomRight.x = x;\n      }\n\n      if (bottomRight.y < 0 || y > bottomRight.y) {\n        bottomRight.y = y;\n      }\n    }\n\n    var seatRadius = Piletilevi.venuemap.SEAT_CIRCLE_RADIUS;\n    return {\n      x: topLeft.x - seatRadius,\n      y: topLeft.y - seatRadius,\n      width: bottomRight.x - topLeft.x + seatRadius * 2,\n      height: bottomRight.y - topLeft.y + seatRadius * 2\n    };\n  };\n\n  var createRowNumberNode = function createRowNumberNode(seat1, seat2) {\n    var alignedLeft = seat1.x <= seat2.x;\n    var position = seat1.x;\n\n    if (alignedLeft) {\n      position -= Piletilevi.venuemap.SEAT_CIRCLE_RADIUS * 2;\n    } else {\n      position += Piletilevi.venuemap.SEAT_CIRCLE_RADIUS * 2;\n    }\n\n    var calculateAngle = function calculateAngle(x1, y1, x2, y2) {\n      return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n    };\n\n    var angle = Math.round(alignedLeft ? calculateAngle(seat1.x, seat1.y, seat2.x, seat2.y) : calculateAngle(seat2.x, seat2.y, seat1.x, seat1.y));\n    var transform = 'rotate(' + angle + ',' + seat1.x + ',' + seat1.y + ')';\n    var flipped = venueMap.isPlacesMapFlipped();\n\n    if (flipped) {\n      transform += ', rotate(180 ' + position + ' ' + seat1.y + ')';\n    }\n\n    var anchor = alignedLeft && !flipped || !alignedLeft && flipped ? 'end' : 'start';\n    var node = Piletilevi.venuemap.Utilities.createSvgNode('text', {\n      'class': 'place_detail',\n      x: position,\n      y: seat1.y,\n      dy: '0.35em',\n      // center align vertically\n      'transform': transform,\n      'stroke-width': 0,\n      'text-anchor': anchor,\n      // center align horizontally\n      'font-size': 10,\n      'fill': '#999999'\n    });\n    var textNode = document.createTextNode(seat1.row);\n    node.appendChild(textNode);\n    return node;\n  };\n};\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ 0:
/*!**************************!*\
  !*** multi ./src/app.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/app.js */\"./src/app.js\");\n\n\n//# sourceURL=webpack:///multi_./src/app.js?");

/***/ })

/******/ });